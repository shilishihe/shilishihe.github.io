<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java线程安全</title>
    <link href="/2025/08/20/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2025/08/20/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java线程安全"><a href="#Java线程安全" class="headerlink" title="Java线程安全"></a>Java线程安全</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="一、Java内存模型（JMM）的本质与核心机制"><a href="#一、Java内存模型（JMM）的本质与核心机制" class="headerlink" title="一、Java内存模型（JMM）的本质与核心机制"></a>一、Java内存模型（JMM）的本质与核心机制</h3><p>JMM是<strong>抽象规范</strong>而非物理结构，旨在解决多线程环境下的内存可见性、原子性和有序性问题，屏蔽不同硬件（如x86&#x2F;ARM）的内存访问差异。</p><h4 id="1-核心结构：主内存与工作内存"><a href="#1-核心结构：主内存与工作内存" class="headerlink" title="1. 核心结构：主内存与工作内存"></a>1. <strong>核心结构：主内存与工作内存</strong></h4><ul><li><strong>主内存</strong>：所有线程共享，存储变量实际值（对应JVM堆内存）。</li><li><strong>工作内存</strong>：线程私有，存储主内存变量的副本（对应CPU寄存器&#x2F;L1-L3缓存）。</li><li><strong>交互操作</strong>：通过8种原子指令实现同步（如<code>read</code>&#x2F;<code>load</code>读取，<code>store</code>&#x2F;<code>write</code>写入）。</li></ul><h4 id="2-三大特性保障机制"><a href="#2-三大特性保障机制" class="headerlink" title="2. 三大特性保障机制"></a>2. <strong>三大特性保障机制</strong></h4><ul><li><strong>原子性</strong>  <ul><li>基本数据类型（如<code>int</code>）读写天然原子；<code>long/double</code>在32位JVM上可能非原子，需<code>volatile</code>。  </li><li>复合操作（如<code>i++</code>）需通过<code>synchronized</code>或原子类（如<code>AtomicInteger</code>）保证原子性。</li></ul></li><li><strong>可见性</strong>  <ul><li>根源：线程修改变量后未及时刷新主内存。  </li><li>解决方案：  <ul><li><code>volatile</code>：强制写操作刷新主内存，读操作从主内存重新加载。  </li><li><code>synchronized</code>：解锁时刷新工作内存到主内存，加锁时清空工作内存。  </li><li><code>final</code>：构造函数结束后，变量值对其他线程立即可见。</li></ul></li></ul></li><li><strong>有序性</strong>  <ul><li>根源：编译器&#x2F;CPU指令重排序破坏多线程语义（如单例模式的双重检查锁问题）。  </li><li>解决方案：  <ul><li><code>happens-before</code>原则：定义操作间的偏序关系（如程序顺序规则、<code>volatile</code>规则）。  </li><li>内存屏障：JVM插入屏障指令禁止重排序（如<code>LoadLoad</code>、<code>StoreStore</code>）。</li></ul></li></ul></li></ul><h4 id="3-happens-before原则的核心规则"><a href="#3-happens-before原则的核心规则" class="headerlink" title="3. happens-before原则的核心规则"></a>3. <strong><code>happens-before</code>原则的核心规则</strong></h4><table><thead><tr><th><strong>规则</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>程序顺序规则</td><td>单线程内代码顺序执行</td></tr><tr><td>监视器锁规则</td><td>解锁操作先于后续加锁操作</td></tr><tr><td><code>volatile</code>变量规则</td><td><code>volatile</code>写操作先于后续读操作</td></tr><tr><td>线程启动&#x2F;终止规则</td><td><code>Thread.start()</code>先于线程内操作；线程内操作先于<code>Thread.join()</code>返回</td></tr><tr><td>传递性规则</td><td>A先于B，B先于C → A先于C</td></tr></tbody></table><hr><h3 id="二、volatile与synchronized在Android中的对比解析"><a href="#二、volatile与synchronized在Android中的对比解析" class="headerlink" title="二、volatile与synchronized在Android中的对比解析"></a>二、<code>volatile</code>与<code>synchronized</code>在Android中的对比解析</h3><h4 id="1-解决的问题场景"><a href="#1-解决的问题场景" class="headerlink" title="1. 解决的问题场景"></a>1. <strong>解决的问题场景</strong></h4><table><thead><tr><th><strong>关键字</strong></th><th><strong>核心作用</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td><code>volatile</code></td><td>保证可见性、禁止指令重排序（不保证原子性）</td><td>状态标志位（如线程终止控制）</td></tr><tr><td><code>synchronized</code></td><td>保证原子性、可见性、有序性（通过互斥锁）</td><td>共享资源修改（如计数器）、单例模式</td></tr></tbody></table><h4 id="2-底层实现原理"><a href="#2-底层实现原理" class="headerlink" title="2. 底层实现原理"></a>2. <strong>底层实现原理</strong></h4><ul><li><p><strong><code>volatile</code>的底层机制</strong><br>通过插入<strong>内存屏障</strong>实现：  </p><ul><li>写操作后插入<code>StoreLoad</code>屏障：强制刷新写缓冲区到主内存，并使其他CPU缓存失效（基于MESI协议）。  </li><li>读操作前插入<code>LoadLoad</code>屏障：禁止后续读操作与当前读操作重排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写操作示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 触发StoreStore + StoreLoad屏障</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;   <span class="hljs-comment">// 触发LoadLoad屏障</span><br>            <span class="hljs-comment">// 读取最新值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>synchronized</code>的底层机制</strong><br>依赖JVM的<strong>监视器锁（Monitor）</strong> 实现：  </p><ul><li><strong>字节码指令</strong>：同步代码块编译为<code>monitorenter</code>&#x2F;<code>monitorexit</code>指令；同步方法通过<code>ACC_SYNCHRONIZED</code>标志识别。  </li><li><strong>锁升级优化</strong>（JDK 6+）：  <table><thead><tr><th><strong>锁类型</strong></th><th><strong>适用场景</strong></th><th><strong>实现方式</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>单线程重复获取锁</td><td>标记线程ID，无竞争直接进入</td></tr><tr><td>轻量级锁</td><td>多线程交替访问无竞争</td><td>CAS自旋尝试获取锁</td></tr><tr><td>重量级锁</td><td>多线程激烈竞争</td><td>操作系统互斥量（Mutex）阻塞线程</td></tr></tbody></table></li></ul></li></ul><h4 id="3-关键特性对比"><a href="#3-关键特性对比" class="headerlink" title="3. 关键特性对比"></a>3. <strong>关键特性对比</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><code>volatile</code></th><th><code>synchronized</code></th><th><strong>原子类（如<code>AtomicInteger</code>）</strong></th></tr></thead><tbody><tr><td><strong>原子性</strong></td><td>❌（仅单次读写）</td><td>✅（同步块内复合操作）</td><td>✅（CAS实现）</td></tr><tr><td><strong>可见性</strong></td><td>✅（内存屏障强制刷新）</td><td>✅（锁释放时刷新主内存）</td><td>✅</td></tr><tr><td><strong>有序性</strong></td><td>✅（禁止重排序）</td><td>✅（同步块内有序）</td><td>❌（部分保证）</td></tr><tr><td><strong>性能开销</strong></td><td>低（仅内存屏障）</td><td>高（锁竞争升级可能阻塞线程）</td><td>中（CAS自旋）</td></tr></tbody></table><h4 id="4-Android开发中的特殊考量"><a href="#4-Android开发中的特殊考量" class="headerlink" title="4. Android开发中的特殊考量"></a>4. <strong>Android开发中的特殊考量</strong></h4><ul><li><p><strong><code>volatile</code>适用场景</strong>  </p><ul><li>单次写入的状态标志（如<code>boolean isRunning</code>）。  </li><li>双重检查锁单例模式中修饰实例变量（防止指令重排序导致对象未初始化完成）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 禁止重排序</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>synchronized</code>注意事项</strong>  </p><ul><li><strong>避免UI线程阻塞</strong>：同步块执行时间过长可能导致ANR（如避免在UI线程同步操作大列表）。  </li><li><strong>锁对象选择</strong>：使用<code>private final Object</code>而非字符串常量（防止意外锁冲突）。  </li><li><strong>死锁预防</strong>：按固定顺序获取多把锁（如先锁A再锁B）。</li></ul></li></ul><hr><h3 id="三、总结与工程实践建议"><a href="#三、总结与工程实践建议" class="headerlink" title="三、总结与工程实践建议"></a>三、总结与工程实践建议</h3><ul><li><strong>JMM本质</strong>：通过抽象规范统一多线程行为，依赖内存屏障与<code>happens-before</code>保证一致性。  </li><li><strong>并发工具选择</strong>：  <ul><li>简单状态标志 → <code>volatile</code>  </li><li>复合操作（如<code>i++</code>） → <code>synchronized</code>或原子类  </li><li>高频读写分离 → <code>ReadWriteLock</code>或<code>StampedLock</code></li></ul></li><li><strong>Android优化方向</strong>：  <ul><li>最小化同步范围（如同步代码块而非整个方法）。  </li><li>优先使用并发工具类（如<code>ConcurrentHashMap</code>替代手动同步<code>HashMap</code>）。</li></ul></li></ul><p>Java中的锁对象通过<strong>互斥访问、内存可见性保证和有序性控制</strong>三大机制保障线程安全，其核心原理围绕<code>synchronized</code>关键字和显式锁（如<code>ReentrantLock</code>）展开。以下从底层实现到应用实践进行系统解析：</p><hr><h2 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h2><h3 id="一、锁的核心保障机制"><a href="#一、锁的核心保障机制" class="headerlink" title="一、锁的核心保障机制"></a>一、锁的核心保障机制</h3><ol><li><p><strong>互斥性（Mutual Exclusion）</strong>  </p><ul><li>锁确保同一时刻仅有一个线程能持有锁并执行临界区代码，其他线程被阻塞或等待，避免并发修改共享资源导致的数据竞争（如计数器<code>i++</code>的非原子操作）。  </li><li><strong>实现原理</strong>：  <ul><li><code>synchronized</code>通过对象监视器（Monitor）的<code>_owner</code>字段记录锁持有者，竞争线程进入<code>_EntryList</code>队列等待。  </li><li><code>ReentrantLock</code>基于AQS（AbstractQueuedSynchronizer）的<code>state</code>变量和CLH队列管理锁竞争。</li></ul></li></ul></li><li><p><strong>内存可见性（Memory Visibility）</strong>  </p><ul><li>线程释放锁时强制刷新工作内存到主内存，获取锁时从主内存重新加载变量值，确保共享数据的修改对所有线程立即可见。  </li><li><strong>对比<code>volatile</code></strong>：  <ul><li><code>volatile</code>仅保证单次读写的可见性，而锁能保障<strong>复合操作</strong>（如先检查后更新）的可见性。</li></ul></li></ul></li><li><p><strong>有序性（Ordering）</strong>  </p><ul><li>锁内部的<code>happens-before</code>规则确保临界区内的代码不会因指令重排序而乱序执行，例如单例模式的双重检查锁中需用<code>volatile</code>禁止重排序。</li></ul></li></ol><hr><h3 id="二、底层实现机制"><a href="#二、底层实现机制" class="headerlink" title="二、底层实现机制"></a>二、底层实现机制</h3><h4 id="1-synchronized关键字"><a href="#1-synchronized关键字" class="headerlink" title="1. synchronized关键字"></a>1. <code>synchronized</code>关键字</h4><ul><li><p><strong>对象头与锁状态</strong><br>每个对象头（Mark Word）存储锁标志位，标识锁状态（无锁、偏向锁、轻量级锁、重量级锁）。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对象头结构（64位JVM）</span><br>| 锁标志位 (2bit) | 状态             | 存储内容                |<br>|----------------|------------------|------------------------|<br>| <span class="hljs-number">01</span>             | 无锁             | 对象哈希码、分代年龄    |<br>| <span class="hljs-number">01</span>             | 偏向锁           | 线程ID、Epoch、分代年龄|<br>| <span class="hljs-number">00</span>             | 轻量级锁         | 指向栈中锁记录的指针    |<br>| <span class="hljs-number">10</span>             | 重量级锁         | 指向Monitor的指针      |<br></code></pre></td></tr></table></figure></li><li><p><strong>锁升级流程</strong>（JDK 6+优化）  </p><ul><li><strong>偏向锁</strong>：单线程重复访问时直接进入同步块（无CAS）。  </li><li><strong>轻量级锁</strong>：多线程交替执行时通过CAS自旋避免阻塞（竞争失败则升级）。  </li><li><strong>重量级锁</strong>：激烈竞争时通过操作系统的互斥量（Mutex）阻塞线程。</li></ul><pre><code class=" mermaid">graph LR  A[无锁] --&gt;|单线程访问| B[偏向锁]  B --&gt;|其他线程竞争| C[轻量级锁]  C --&gt;|自旋失败| D[重量级锁]</code></pre></li><li><p><strong>Monitor机制</strong>  </p><ul><li>每个对象关联一个<code>ObjectMonitor</code>，核心字段包括：  <ul><li><code>_owner</code>：持有锁的线程  </li><li><code>_EntryList</code>：阻塞等待锁的线程队列  </li><li><code>_WaitSet</code>：调用<code>wait()</code>的线程队列。</li></ul></li><li>加锁流程：  <ol><li>线程通过<code>monitorenter</code>指令尝试获取Monitor。  </li><li>若<code>_owner</code>为空则获取锁，否则进入<code>_EntryList</code>阻塞。  </li><li>退出时通过<code>monitorexit</code>释放锁并唤醒<code>_EntryList</code>中的线程。</li></ol></li></ul></li></ul><h4 id="2-显式锁（ReentrantLock）"><a href="#2-显式锁（ReentrantLock）" class="headerlink" title="2. 显式锁（ReentrantLock）"></a>2. 显式锁（<code>ReentrantLock</code>）</h4><ul><li><strong>AQS同步框架</strong>  <ul><li>内部通过<code>state</code>变量（0表示未锁定，&gt;0表示重入次数）和FIFO队列管理竞争线程。  </li><li><strong>公平性</strong>：  <ul><li>公平锁按请求顺序分配（性能较低）；  </li><li>非公平锁允许插队（默认模式，吞吐量高）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 公平锁</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="三、锁的优化策略"><a href="#三、锁的优化策略" class="headerlink" title="三、锁的优化策略"></a>三、锁的优化策略</h3><ol><li><strong>锁粗化（Lock Coarsening）</strong><br>合并多个相邻的同步块为一个，减少频繁加解锁开销（如循环内多次锁合并为一次）。  </li><li><strong>锁消除（Lock Elimination）</strong><br>JVM通过逃逸分析移除不可能存在竞争的锁（如局部<code>StringBuffer</code>的同步操作）。  </li><li><strong>读写分离（ReadWriteLock）</strong><br>适用读多写少场景，允许多线程并发读，写操作独占访问（<code>ReentrantReadWriteLock</code>）。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>rwLock.readLock().lock();   <span class="hljs-comment">// 读锁可共享</span><br>rwLock.writeLock().lock();  <span class="hljs-comment">// 写锁独占</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="四、线程安全的工程实践"><a href="#四、线程安全的工程实践" class="headerlink" title="四、线程安全的工程实践"></a>四、线程安全的工程实践</h3><ol><li><p><strong>避免死锁</strong>  </p><ul><li><strong>固定锁顺序</strong>：按全局顺序获取锁（如按<code>hashCode</code>排序）。  </li><li><strong>超时机制</strong>：<code>ReentrantLock.tryLock(5, TimeUnit.SECONDS)</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转账场景的锁顺序控制</span><br><span class="hljs-keyword">synchronized</span> (firstAccount) &#123;<br>  <span class="hljs-keyword">synchronized</span> (secondAccount) &#123;<br>    <span class="hljs-comment">// 转账逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>减小锁粒度</strong>  </p><ul><li>用细粒度锁（如分段锁）替代全局锁，例如<code>ConcurrentHashMap</code>分桶加锁。</li></ul></li><li><p><strong>替代方案选择</strong>  </p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>优势</strong></th></tr></thead><tbody><tr><td>简单计数器</td><td><code>AtomicInteger</code></td><td>CAS无锁，轻量高效</td></tr><tr><td>读多写少</td><td><code>ReentrantReadWriteLock</code></td><td>读并发性高</td></tr><tr><td>复杂条件等待</td><td><code>Condition.await()</code></td><td>比<code>wait()</code>更灵活的条件控制</td></tr></tbody></table></li></ol><hr><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>Java锁对象通过 <strong>互斥性、内存可见性、有序性</strong> 三重保障实现线程安全：  </p><ul><li><strong><code>synchronized</code></strong> 以内置锁形式简化开发，依赖Monitor和锁升级优化性能；  </li><li><strong>显式锁</strong>（如<code>ReentrantLock</code>）提供更灵活的公平性、超时和条件控制；  </li><li><strong>工程实践</strong>需结合锁粒度控制、死锁预防及无锁数据结构（如原子类）以平衡安全与性能。在Android开发中，需特别注意避免主线程持锁导致的ANR，优先使用轻量级同步机制。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池在Android系统中的使用场景分析</title>
    <link href="/2025/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <url>/2025/08/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Java线程池在Android系统中的使用场景分析"><a href="#Java线程池在Android系统中的使用场景分析" class="headerlink" title="Java线程池在Android系统中的使用场景分析"></a>Java线程池在Android系统中的使用场景分析</h1><p>线程池作为Java并发编程的核心组件，其构造函数的参数配置直接决定了资源利用率、系统稳定性和任务调度效率。以下从<strong>参数定义</strong>、<strong>协作机制</strong>、<strong>高阶配置</strong>及<strong>避坑实践</strong>四个维度深度解析：</p><hr><h3 id="⚙️-一、ThreadPoolExecutor核心参数详解"><a href="#⚙️-一、ThreadPoolExecutor核心参数详解" class="headerlink" title="⚙️ 一、ThreadPoolExecutor核心参数详解"></a>⚙️ 一、ThreadPoolExecutor核心参数详解</h3><h4 id="1-corePoolSize（核心线程数）"><a href="#1-corePoolSize（核心线程数）" class="headerlink" title="1. corePoolSize（核心线程数）"></a>1. <strong><code>corePoolSize</code>（核心线程数）</strong></h4><ul><li><strong>定义</strong>：线程池长期维持的线程数量，即使空闲也不会销毁（除非开启<code>allowCoreThreadTimeOut</code>）</li><li><strong>运行逻辑</strong>：<ul><li>当任务数 ≤ <code>corePoolSize</code>时，<strong>立即创建新线程</strong>执行任务（即使有空闲线程）</li><li>默认不预创建，可通过<code>prestartCoreThread()</code>主动初始化</li></ul></li><li><strong>场景建议</strong>：CPU密集型任务（如图像处理）设为CPU核数，避免线程过多竞争CPU</li></ul><h4 id="2-maximumPoolSize（最大线程数）"><a href="#2-maximumPoolSize（最大线程数）" class="headerlink" title="2. maximumPoolSize（最大线程数）"></a>2. <strong><code>maximumPoolSize</code>（最大线程数）</strong></h4><ul><li><strong>定义</strong>：线程池允许的最大线程数（核心线程 + 非核心线程）</li><li><strong>扩容规则</strong>：<ul><li>仅当<strong>任务队列已满</strong>且当前线程数 &lt; <code>maximumPoolSize</code>时，创建非核心线程</li><li>非核心线程空闲超时(<code>keepAliveTime</code>)后销毁</li></ul></li><li><strong>风险控制</strong>：高并发场景需设上限（如100），防止线程爆炸（<code>Integer.MAX_VALUE</code>为危险值）</li></ul><h4 id="3-keepAliveTime-unit（线程空闲超时）"><a href="#3-keepAliveTime-unit（线程空闲超时）" class="headerlink" title="3. keepAliveTime+ unit（线程空闲超时）"></a>3. <strong><code>keepAliveTime</code>+ <code>unit</code>（线程空闲超时）</strong></h4><ul><li><strong>定义</strong>：非核心线程闲置超过此时长后自动销毁</li><li><strong>特殊配置</strong>：<ul><li>调用<code>allowCoreThreadTimeOut(true)</code>可让核心线程也受超时约束</li><li>设为<code>Long.MAX_VALUE</code>可近似禁用回收（慎用！）</li></ul></li><li><strong>调优建议</strong>：短任务场景（如API请求）设为60秒，长任务场景适当延长</li></ul><h4 id="4-workQueue（任务队列）"><a href="#4-workQueue（任务队列）" class="headerlink" title="4. workQueue（任务队列）"></a>4. <strong><code>workQueue</code>（任务队列）</strong></h4><ul><li><strong>核心作用</strong>：缓存待执行任务，不同队列类型直接影响线程池行为</li></ul><table><thead><tr><th><strong>队列类型</strong></th><th><strong>特性</strong></th><th><strong>适用场景</strong></th><th><strong>风险</strong></th></tr></thead><tbody><tr><td><code>SynchronousQueue</code></td><td>无容量队列，任务直接移交线程（无缓存）</td><td>实时性要求高的短任务（OkHttp）</td><td>易触发非核心线程创建</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>无界队列（默认<code>Integer.MAX_VALUE</code>）</td><td>流量平稳的串行任务（数据库操作）</td><td>可能引发OOM</td></tr><tr><td><code>ArrayBlockingQueue</code></td><td>有界队列（固定容量）</td><td>需控制内存的并发场景</td><td>队列满时触发拒绝策略</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td>优先级队列（任务需实现<code>Comparable</code>）</td><td>任务分级调度（紧急任务优先）</td><td>可能引起饥饿问题</td></tr></tbody></table><h4 id="5-threadFactory（线程工厂）"><a href="#5-threadFactory（线程工厂）" class="headerlink" title="5. threadFactory（线程工厂）"></a>5. <strong><code>threadFactory</code>（线程工厂）</strong></h4><ul><li><p><strong>核心能力</strong>：自定义线程属性（名称、优先级、守护状态）</p></li><li><p><strong>实战案例</strong>：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ThreadFactory factory = r -&gt; &#123;  <br>    <span class="hljs-keyword">Thread</span> t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>(r)<span class="hljs-comment">;  </span><br>    t.setName(<span class="hljs-string">&quot;network-thread-&quot;</span> + t.getId())<span class="hljs-comment">;  </span><br>    t.setPriority(<span class="hljs-keyword">Thread</span>.NORM_PRIORITY)<span class="hljs-comment">;  </span><br>    <span class="hljs-keyword">return</span> t<span class="hljs-comment">;  </span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>价值</strong>：便于日志追踪和问题定位（如定位网络线程泄露）</p></li></ul><h4 id="6-handler（拒绝策略）"><a href="#6-handler（拒绝策略）" class="headerlink" title="6. handler（拒绝策略）"></a>6. <strong><code>handler</code>（拒绝策略）</strong></h4><ul><li><strong>触发条件</strong>：任务队列满且线程数达<code>maximumPoolSize</code></li></ul><table><thead><tr><th><strong>策略类型</strong></th><th><strong>行为</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出<code>RejectedExecutionException</code></td><td>关键业务（如支付订单）</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>由提交任务的线程直接执行</td><td>避免任务丢失的通用场景</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列最旧任务，重试新任务</td><td>实时数据流（如传感器数据）</td></tr><tr><td><code>DiscardPolicy</code></td><td>静默丢弃新任务</td><td>非关键任务（统计日志）</td></tr></tbody></table><hr><h3 id="🔄-二、参数协作机制与任务提交流程"><a href="#🔄-二、参数协作机制与任务提交流程" class="headerlink" title="🔄 二、参数协作机制与任务提交流程"></a>🔄 二、参数协作机制与任务提交流程</h3><ol><li><p><strong>任务提交优先级</strong>：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coq">graph TD<br>A[新任务提交] --&gt; B&#123;线程数 &lt; corePoolSize?&#125;<br>B --&gt;|<span class="hljs-type">是| C</span>[创建核心线程执行]<br>B --&gt;|<span class="hljs-type">否| D</span>&#123;任务队列未满?&#125;<br>D --&gt;|<span class="hljs-type">是| E</span>[任务入队等待]<br>D --&gt;|<span class="hljs-type">否| F</span>&#123;线程数 &lt; maximumPoolSize?&#125;<br>F --&gt;|<span class="hljs-type">是| G</span>[创建非核心线程执行]<br>F --&gt;|<span class="hljs-type">否| H</span>[触发拒绝策略]<br></code></pre></td></tr></table></figure></li><li><p><strong>线程回收逻辑</strong>：</p><ul><li>非核心线程闲置 &gt; <code>keepAliveTime</code>→ 自动销毁</li><li>核心线程默认永久存活（除非开启<code>allowCoreThreadTimeOut</code>）</li></ul></li></ol><hr><h3 id="🛠️-三、高阶配置与避坑指南"><a href="#🛠️-三、高阶配置与避坑指南" class="headerlink" title="🛠️ 三、高阶配置与避坑指南"></a>🛠️ 三、高阶配置与避坑指南</h3><ol><li><strong>动态调参</strong>：<ul><li>运行时修改<code>corePoolSize</code>&#x2F;<code>maximumPoolSize</code>（需谨慎同步）</li><li>示例：突发流量时临时扩容<code>maximumPoolSize</code></li></ul></li><li><strong>监控指标</strong>：<ul><li><code>getActiveCount()</code>：活跃线程数</li><li><code>getQueue().size()</code>：队列堆积量</li><li><strong>推荐</strong>：集成Micrometer暴露线程池Metrics</li></ul></li><li><strong>典型陷阱</strong>：<ul><li><strong>OOM风险</strong>：无界队列(<code>LinkedBlockingQueue</code>) + 长任务 → 内存溢出</li><li><strong>响应延迟</strong>：<code>FixedThreadPool</code>处理慢任务时阻塞队列</li><li><strong>解决方案</strong>：<ul><li>使用有界队列 + 合理拒绝策略</li><li>I&#x2F;O密集型任务调高<code>maximumPoolSize</code>（建议 ≤ 2 * CPU核数）</li></ul></li></ul></li></ol><hr><h3 id="💎-四、终极实践建议"><a href="#💎-四、终极实践建议" class="headerlink" title="💎 四、终极实践建议"></a>💎 四、终极实践建议</h3><ol><li><p><strong>禁用<code>Executors</code>快捷工厂</strong>：</p><ul><li><code>newFixedThreadPool()</code>和<code>newCachedThreadPool()</code>隐藏OOM风险</li><li><strong>替代方案</strong>：手动构造<code>ThreadPoolExecutor</code>控制所有参数</li></ul></li><li><p><strong>资源隔离原则</strong>：</p><ul><li>独立线程池处理网络&#x2F;DB&#x2F;计算任务，避免相互阻塞</li><li>示例：Android中Glide图片加载使用独立线程池</li></ul></li><li><p><strong>超时兜底策略</strong>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">executor.<span class="hljs-built_in">execute</span>(() -&gt; &#123;<br>    Future&lt;?&gt; future = subExecutor.<span class="hljs-built_in">submit</span>(task);<br>    <span class="hljs-keyword">try</span> &#123;<br>        future.<span class="hljs-built_in">get</span>(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS); <span class="hljs-comment">// 超时中断</span><br>    &#125; <span class="hljs-built_in">catch</span> (TimeoutException e) &#123;<br>        future.<span class="hljs-built_in">cancel</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>深入理解每个参数的<strong>设计意图</strong>与<strong>相互制约关系</strong>，是构建高并发、高可靠系统的基石。建议结合<code>jstack</code>和<code>Arthas</code>分析线上线程池状态，持续优化参数配置。</p></blockquote><p>在Android开发中，线程池是管理并发任务的核心工具，其设计直接影响应用性能、资源利用率和稳定性。以下从<strong>系统级应用场景</strong>、<strong>线程池类型对比</strong>、<strong>参数配置艺术</strong>、<strong>避坑指南</strong>及<strong>框架对比</strong>五个维度深度解析：</p><hr><h3 id="一、系统级线程池应用场景"><a href="#一、系统级线程池应用场景" class="headerlink" title="一、系统级线程池应用场景"></a>一、系统级线程池应用场景</h3><ol><li><strong>图片加载框架（如Glide）</strong><ul><li><strong>线程池类型</strong>：<code>FixedThreadPool</code>（CPU核心数）</li><li><strong>原理</strong>：通过固定线程数避免频繁创建&#x2F;销毁线程，任务队列采用优先级调度确保可见图片优先加载。</li><li><strong>优势</strong>：平衡CPU资源与任务吞吐量，防止列表滑动时线程爆炸。</li></ul></li><li><strong>网络请求框架（如Retrofit + OkHttp）</strong><ul><li><strong>线程池类型</strong>：<code>CachedThreadPool</code></li><li><strong>原理</strong>：<code>SynchronousQueue</code>确保请求即时执行，临时线程60秒空闲回收。</li><li><strong>风险</strong>：高并发时线程数可能激增（最大<code>Integer.MAX_VALUE</code>），需配合连接池限制。</li></ul></li><li><strong>数据库操作（Room）</strong><ul><li><strong>线程池类型</strong>：<code>SingleThreadExecutor</code></li><li><strong>原理</strong>：单线程顺序执行任务，避免并发写导致SQLite锁冲突。</li><li><strong>场景</strong>：事务操作、先写后读等需严格顺序的任务。</li></ul></li><li><strong>定时任务（WorkManager）</strong><ul><li><strong>线程池类型</strong>：<code>ScheduledThreadPool</code></li><li><strong>原理</strong>：<code>scheduleAtFixedRate()</code>以固定速率执行周期任务（如心跳包），延迟队列基于最小堆实现。</li></ul></li></ol><hr><h3 id="二、四类线程池深度对比"><a href="#二、四类线程池深度对比" class="headerlink" title="二、四类线程池深度对比"></a>二、四类线程池深度对比</h3><table><thead><tr><th><strong>线程池类型</strong></th><th><strong>工作特性</strong></th><th><strong>内部实现</strong></th><th><strong>适用场景</strong></th><th><strong>风险</strong></th></tr></thead><tbody><tr><td><strong>FixedThreadPool</strong></td><td>固定线程数，无临时线程</td><td>核心线程数&#x3D;最大线程数，无界<code>LinkedBlockingQueue</code></td><td>CPU密集型任务（图片压缩、计算）</td><td>队列堆积导致OOM</td></tr><tr><td><strong>CachedThreadPool</strong></td><td>自动扩容，60秒回收临时线程</td><td>核心线程数&#x3D;0，<code>SynchronousQueue</code>（无缓存）</td><td>短期异步任务（网络请求、日志上报）</td><td>线程数失控（理论无上限）</td></tr><tr><td><strong>SingleThreadExecutor</strong></td><td>单线程顺序执行</td><td>核心线程数&#x3D;1，无界<code>LinkedBlockingQueue</code></td><td>数据库事务、文件顺序读写</td><td>任务阻塞导致延迟</td></tr><tr><td><strong>ScheduledThreadPool</strong></td><td>支持延迟&#x2F;周期性任务</td><td>核心线程固定，<code>DelayedWorkQueue</code></td><td>心跳检测、定时数据同步</td><td>周期任务重叠执行</td></tr></tbody></table><blockquote><p><strong>注</strong>：<code>SingleThreadExecutor</code>本质是<code>FixedThreadPool(1)</code>的特例，但通过<code>FinalizableDelegatedExecutorService</code>包装防止类型强转修改参数。</p></blockquote><hr><h3 id="三、参数配置的艺术"><a href="#三、参数配置的艺术" class="headerlink" title="三、参数配置的艺术"></a>三、参数配置的艺术</h3><ul><li><p><strong>CPU密集型任务</strong>（如图像处理）：</p><p>线程数 ≤ CPU核心数（<code>Runtime.getRuntime().availableProcessors()</code>），避免过多线程竞争CPU。</p></li><li><p><strong>I&#x2F;O密集型任务</strong>（如网络请求）：</p><p>线程数可扩至2×CPU核心数，利用I&#x2F;O等待时间执行其他任务。</p></li><li><p><strong>队列选择</strong>：</p><ul><li><code>ArrayBlockingQueue</code>（有界）：控制内存，但需合理拒绝策略；</li><li><code>SynchronousQueue</code>（无缓存）：避免任务堆积，适合实时任务。</li></ul></li></ul><hr><h3 id="四、避坑指南：线程池的隐患与优化"><a href="#四、避坑指南：线程池的隐患与优化" class="headerlink" title="四、避坑指南：线程池的隐患与优化"></a>四、避坑指南：线程池的隐患与优化</h3><ol><li><strong>内存泄漏</strong><ul><li><strong>根因</strong>：未调用<code>shutdown()</code>导致线程无法回收（尤其<code>Static</code>线程池）。</li><li><strong>解决</strong>：在<code>onDestroy()</code>中调用<code>shutdownNow()</code>并清空任务队列。</li></ul></li><li><strong>拒绝策略选择</strong><ul><li><code>CallerRunsPolicy</code>：由调用线程执行任务（如主线程），可作简易背压机制；</li><li><code>DiscardOldestPolicy</code>：丢弃旧任务，适合实时数据流。</li></ul></li><li><strong>线程复用失效</strong><ul><li><code>CachedThreadPool</code>在任务执行时间过长时，会持续创建新线程，应改用<code>FixedThreadPool</code>限制上限。</li></ul></li></ol><hr><h3 id="五、与替代方案的横向对比"><a href="#五、与替代方案的横向对比" class="headerlink" title="五、与替代方案的横向对比"></a>五、与替代方案的横向对比</h3><ol><li><strong>HandlerThread</strong><ul><li><strong>本质</strong>：单线程+消息队列，适用于串行、低频率任务（如本地日志写入）。</li><li><strong>局限</strong>：无法动态扩容，并发能力弱于线程池。</li></ul></li><li><strong>协程（Kotlin）</strong><ul><li><strong>优势</strong>：轻量级线程（节省内存），结构化取消机制；</li><li><strong>场景</strong>：替代回调嵌套，但底层仍依赖线程池调度（如<code>Dispatchers.IO</code>）。</li></ul></li></ol><hr><h3 id="总结：线程池的架构级思考"><a href="#总结：线程池的架构级思考" class="headerlink" title="总结：线程池的架构级思考"></a>总结：线程池的架构级思考</h3><ul><li><strong>性能敏感场景</strong>：优先自定义<code>ThreadPoolExecutor</code>，而非<code>Executors</code>预设（避免无界队列风险）；</li><li><strong>资源隔离</strong>：不同业务（如网络&#x2F;DB&#x2F;计算）使用独立线程池，防止相互阻塞；</li><li><strong>监控加持</strong>：通过<code>ThreadPoolExecutor</code>的<code>getActiveCount()</code>等方法实时监控负载。</li></ul><blockquote><p>在移动端资源受限环境下，线程池的精细化配置是平衡<strong>性能</strong>、<strong>资源</strong>与<strong>稳定性</strong>的关键。建议结合<code>Systrace</code>分析任务调度瓶颈，持续优化参数。</p></blockquote><p>在 Android 和 Java 应用中，监控线程池是保障系统稳定性和性能优化的关键环节。以下是多维度监控方案及实践建议：</p><hr><h3 id="⚙️-一、原生-API-监控（编码层）"><a href="#⚙️-一、原生-API-监控（编码层）" class="headerlink" title="⚙️ 一、原生 API 监控（编码层）"></a>⚙️ <strong>一、原生 API 监控（编码层）</strong></h3><p>通过 <code>ThreadPoolExecutor</code>提供的内置方法获取实时指标：</p><ol><li><p><strong>核心指标</strong>：</p><ul><li><code>getPoolSize()</code>：当前线程总数（核心+非核心）。</li><li><code>getActiveCount()</code>：正在执行任务的线程数（瞬时值）。</li><li><code>getQueue().size()</code>：任务队列堆积量（需警惕无界队列 OOM 风险）。</li><li><code>getCompletedTaskCount()</code>：已完成任务总量（统计吞吐量）。</li><li><code>getLargestPoolSize()</code>：历史最大线程数（评估资源峰值）。</li></ul></li><li><p><strong>自定义定时监控任务</strong>：</p><p>使用 <code>ScheduledExecutorService</code>定期采集数据并输出日志或告警：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">ScheduledExecutorService<span class="hljs-built_in"> monitor </span>= Executors.newSingleThreadScheduledExecutor();<br>monitor.scheduleAtFixedRate(() -&gt; &#123;<br>    log.info(<span class="hljs-string">&quot;Active: &#123;&#125;, Queue: &#123;&#125;&quot;</span>, executor.getActiveCount(), executor.getQueue().size());<br>&#125;, 0, 5, TimeUnit.SECONDS); // 每 5 秒采集一次。<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="🛠️-二、扩展重写线程池（增强监控）"><a href="#🛠️-二、扩展重写线程池（增强监控）" class="headerlink" title="🛠️ 二、扩展重写线程池（增强监控）"></a>🛠️ <strong>二、扩展重写线程池（增强监控）</strong></h3><p>继承 <code>ThreadPoolExecutor</code>并重写钩子方法，实现精细化监控：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitoredThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void beforeExecute(<span class="hljs-type">Thread</span> t, <span class="hljs-type">Runnable</span> r) &#123;<br>        <span class="hljs-keyword">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间、线程状态。</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void afterExecute(<span class="hljs-type">Runnable</span> r, <span class="hljs-type">Throwable</span> t) &#123;<br>        <span class="hljs-keyword">super</span>.afterExecute(r, t);<br>        <span class="hljs-comment">// 统计任务耗时、异常捕获。</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void terminated() &#123;<br>        <span class="hljs-keyword">super</span>.terminated();<br>        <span class="hljs-comment">// 线程池关闭时输出最终统计报告。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong>：可监控单个任务生命周期，统计平均&#x2F;最大耗时等。</p><hr><h3 id="📊-三、JMX-与可视化工具（生产级监控）"><a href="#📊-三、JMX-与可视化工具（生产级监控）" class="headerlink" title="📊 三、JMX 与可视化工具（生产级监控）"></a>📊 <strong>三、JMX 与可视化工具（生产级监控）</strong></h3><ol><li><p><strong>JMX（Java Management Extensions）</strong>：</p><ul><li><p>暴露线程池 MBean，通过 JConsole 或 VisualVM 实时查看：</p><ul><li>线程数、队列大小、拒绝任务数等指标。</li></ul></li><li><p><strong>操作示例</strong>：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">ManagementFactory.getPlatformMBeanServer().registerMBean(<br>    executor, <span class="hljs-keyword">new</span> ObjectName(<span class="hljs-string">&quot;com.app:type=ThreadPool&quot;</span>)<br>); <span class="hljs-comment">// 注册 MBean。</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>可视化工具</strong>：</p><ul><li><strong>VisualVM</strong>：实时监控线程状态、CPU 占用、堆内存（内置 JDK）。</li><li><strong>Prometheus + Grafana</strong>：<ul><li>通过 <code>micrometer-core</code>暴露指标（如 <code>executor_queue_size</code>）。</li><li>配置 Dashboard 展示队列堆积趋势、线程利用率。</li></ul></li></ul></li></ol><hr><h3 id="🔧-四、第三方框架集成（高效运维）"><a href="#🔧-四、第三方框架集成（高效运维）" class="headerlink" title="🔧 四、第三方框架集成（高效运维）"></a>🔧 <strong>四、第三方框架集成（高效运维）</strong></h3><ol><li><p><strong>Arthas</strong>：</p><ul><li><p>命令行诊断工具，动态查看线程池状态：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span> getActiveCount returnObj<br></code></pre></td></tr></table></figure></li><li><p>支持在线分析任务阻塞原因。</p></li></ul></li><li><p><strong>Spring Boot Actuator</strong>：</p><ul><li><p>暴露 <code>/actuator/metrics</code>端点，集成 <code>ThreadPoolTaskExecutor</code>指标：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">management:</span><br><span class="hljs-symbol">  metrics:</span><br><span class="hljs-symbol">    tags:</span><br><span class="hljs-symbol">      application:</span> $<span class="hljs-punctuation">&#123;</span>spring.application.name<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>监控指标：<code>executor_active_threads</code>、<code>executor_completed_tasks</code>。</p></li></ul></li><li><p><strong>Hippo4j</strong>：</p><ul><li>动态调整线程池参数（如核心线程数），实时查看队列堆积告警。</li></ul></li></ol><hr><h3 id="🧩-五、异常与拒绝策略监控"><a href="#🧩-五、异常与拒绝策略监控" class="headerlink" title="🧩 五、异常与拒绝策略监控"></a>🧩 <strong>五、异常与拒绝策略监控</strong></h3><ol><li><p><strong>异常捕获</strong>：</p><ul><li><p>通过 <code>Future</code>捕获任务异常：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Future&lt;?&gt; future = executor.submit(task);<br><span class="hljs-keyword">try</span> &#123;<br>    future.<span class="hljs-keyword">get</span>();<br>&#125; catch (ExecutionException e) &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;Task failed&quot;</span>, e.getCause());<br>&#125;。<br></code></pre></td></tr></table></figure></li><li><p>设置全局异常处理器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactoryBuilder()<br>    .setUncaughtExceptionHandler<span class="hljs-function"><span class="hljs-params">((t, e) -&gt; log.error(<span class="hljs-string">&quot;Thread &#123;&#125; crashed&quot;</span>, t.getName(), e))</span></span><br><span class="hljs-function">    .<span class="hljs-title">build</span><span class="hljs-params">()</span>;。</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>拒绝策略统计</strong>：</p><ul><li><p>自定义 <code>RejectedExecutionHandler</code>记录拒绝次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingRejectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        counter.incrementAndGet();<br>    &#125;<br>&#125;。<br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="💎-总结：监控方案选择建议"><a href="#💎-总结：监控方案选择建议" class="headerlink" title="💎 总结：监控方案选择建议"></a>💎 <strong>总结：监控方案选择建议</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>核心优势</strong></th></tr></thead><tbody><tr><td>开发调试</td><td>原生 API + 定时日志</td><td>快速实现，无依赖</td></tr><tr><td>生产环境实时监控</td><td>Prometheus + Grafana</td><td>可视化告警，历史分析</td></tr><tr><td>动态调参需求</td><td>Hippo4j</td><td>线程池参数热更新</td></tr><tr><td>在线问题诊断</td><td>Arthas</td><td>无需重启，深度追踪</td></tr></tbody></table><blockquote><p><strong>避坑指南</strong>：</p><ul><li>避免高频调用 <code>getQueue().size()</code>（某些队列实现为 O(n) 操作）。</li><li>无界队列（如 <code>LinkedBlockingQueue</code>）需配合拒绝策略防 OOM。</li><li>监控线程池状态机（RUNNING&#x2F;SHUTDOWN）确保优雅关闭。</li></ul></blockquote><p>通过分层监控策略，可精准定位资源瓶颈（如队列突增、线程泄漏），结合性能工具（如 Systrace）优化任务调度逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案</title>
    <link href="/2025/08/19/Dio-%E9%98%BF%E9%87%8C%E4%BA%91-HTTPDNS%EF%BC%88HTTP-API%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9B%B4%E8%BF%9E%E6%96%B9%E6%A1%88/"/>
    <url>/2025/08/19/Dio-%E9%98%BF%E9%87%8C%E4%BA%91-HTTPDNS%EF%BC%88HTTP-API%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9B%B4%E8%BF%9E%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Dio-阿里云-HTTPDNS（HTTP-API）实现跨平台动态域名解析直连方案"><a href="#Dio-阿里云-HTTPDNS（HTTP-API）实现跨平台动态域名解析直连方案" class="headerlink" title="Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案"></a>Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案</h1><blockquote><p>纯 Dart 实现，支持 <strong>Android &#x2F; iOS &#x2F; Windows</strong>，零平台通道、零 SDK 依赖。</p></blockquote><hr><h2 id="1-背景与目标"><a href="#1-背景与目标" class="headerlink" title="1. 背景与目标"></a>1. 背景与目标</h2><table><thead><tr><th>需求</th><th>说明</th></tr></thead><tbody><tr><td>跨平台</td><td>Android &#x2F; iOS &#x2F; Windows 三端共用一份代码</td></tr><tr><td>不引入官方 SDK</td><td>仅使用阿里云 HTTPDNS 的 <strong>HTTP API</strong></td></tr><tr><td>网络库</td><td>Flutter &#x2F; Dart 的 <strong>Dio</strong></td></tr><tr><td>最终效果</td><td>请求时自动把域名解析成 IP，再以 IP 直连，解决 DNS 劫持、时延等问题</td></tr></tbody></table><hr><h2 id="2-阿里云-HTTPDNS-HTTP-API-速查"><a href="#2-阿里云-HTTPDNS-HTTP-API-速查" class="headerlink" title="2. 阿里云 HTTPDNS HTTP API 速查"></a>2. 阿里云 HTTPDNS HTTP API 速查</h2><table><thead><tr><th>字段</th><th>示例</th></tr></thead><tbody><tr><td>解析节点</td><td><code>http://203.107.1.33</code> 或 <code>https://203.107.1.33</code></td></tr><tr><td>固定前缀</td><td><code>/&#123;Your_Account_ID&#125;</code></td></tr><tr><td>查询参数</td><td><code>host=www.example.com</code></td></tr><tr><td>返回</td><td><strong>纯文本</strong> 单 IPv4 地址，失败为空或 <code>NXDOMAIN</code></td></tr><tr><td>超时建议</td><td>3 s</td></tr><tr><td>QPS 限制</td><td>≤ 200</td></tr></tbody></table><hr><h2 id="3-架构图"><a href="#3-架构图" class="headerlink" title="3. 架构图"></a>3. 架构图</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌────────────┐      ┌────────────────┐      ┌──────────────┐<br>│   App      │─────▶│  DnsHttpClient │─────▶│   目标站点   │<br>│   (Dio)    │      │   Adapter      │      │ (IP直连+SNI) │<br>└────────────┘      └────────────────┘      └──────────────┘<br>          │                 │<br>          │                 ▼<br>          │        ┌────────────────┐<br>          └─────── │  阿里云HTTPDNS │<br>                   │  (HTTP API)    │<br>                   └────────────────┘<br></code></pre></td></tr></table></figure><hr><h2 id="4-核心代码（纯-Dart）"><a href="#4-核心代码（纯-Dart）" class="headerlink" title="4. 核心代码（纯 Dart）"></a>4. 核心代码（纯 Dart）</h2><h3 id="4-1-阿里云-HTTPDNS-解析器"><a href="#4-1-阿里云-HTTPDNS-解析器" class="headerlink" title="4.1 阿里云 HTTPDNS 解析器"></a>4.1 阿里云 HTTPDNS 解析器</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">阿里云 HTTPDNS（HTTP API 版）</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliHttpDns</span> </span>&#123;<br>  <span class="hljs-comment">// 启动IP列表</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; _startDnsIps = [<span class="hljs-string">&#x27;203.107.1.1&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.33&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.34&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.35&#x27;</span>]; <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> _accountId = <span class="hljs-string">&#x27;xxxxxx&#x27;</span>; <span class="hljs-comment">// 账号ID</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Dio _dio = Dio()<br><br>  <span class="hljs-comment">/// <span class="language-markdown">应用内嵌入多个启动 IP 或域名，确保始终与HTTPDNS服务保持连通性</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">请求失败时，自动切换使用下一个启动 IP</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在下列描述的场景中更新并保存服务IP列表</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在App冷启动时进行更新</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在切换网络环境时进行更新</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议每8小时至少更新一次</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">当服务IP列表经过重试发现都无法解析时，立即更新</span></span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; fetchParseServerAddddress(<span class="hljs-built_in">String</span> startDnsIp) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">// 具体代码待实现</span><br>    <span class="hljs-keyword">return</span> dnsServer;<br>  &#125;<br>  <br>  <span class="hljs-comment">/// <span class="language-markdown">解析域名 -&gt; IP，失败返回原域名降级</span></span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; domainNameResolution(<span class="hljs-built_in">String</span> host) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">final</span> res = <span class="hljs-keyword">await</span> _dio.<span class="hljs-keyword">get</span>&lt;<span class="hljs-built_in">String</span>&gt;(<br>        <span class="hljs-string">&#x27;<span class="hljs-subst">$dnsServer</span>/<span class="hljs-subst">$_accountId</span>&#x27;</span>,<br>        queryParameters: &#123;<span class="hljs-string">&#x27;host&#x27;</span>: host&#125;,<br>      );<br>      <span class="hljs-keyword">final</span> ip = (res.data ?? <span class="hljs-string">&#x27;&#x27;</span>).trim();<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">r&#x27;^\d+\.\d+\.\d+\.\d+$&#x27;</span>).hasMatch(ip) ? ip : host;<br>    &#125; <span class="hljs-keyword">catch</span> (_) &#123;<br>      <span class="hljs-keyword">return</span> host; <span class="hljs-comment">// 降级</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-自定义-HttpClientAdapter"><a href="#4-2-自定义-HttpClientAdapter" class="headerlink" title="4.2 自定义 HttpClientAdapter"></a>4.2 自定义 <code>HttpClientAdapter</code></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:io&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/io.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DnsHttpClientAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpClientAdapter</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> HttpClientAdapter _adapter = IOHttpClientAdapter();<br><br>  <span class="hljs-meta">@override</span><br>  Future&lt;ResponseBody&gt; fetch(<br>    RequestOptions options,<br>    Stream&lt;Uint8List&gt;? requestStream,<br>    Future? cancelFuture,<br>  ) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> host = options.uri.host;<br><br>    <span class="hljs-comment">// 已是 IP 直接转发</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">r&#x27;^\d+\.\d+\.\d+\.\d+$&#x27;</span>).hasMatch(host)) &#123;<br>      <span class="hljs-keyword">return</span> _adapter.fetch(options, requestStream, cancelFuture);<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 解析</span><br>    <span class="hljs-keyword">final</span> ip = <span class="hljs-keyword">await</span> AliHttpDns.resolve(host);<br><br>    <span class="hljs-comment">// 2. 替换 URI</span><br>    <span class="hljs-keyword">final</span> uri = options.uri.replace(host: ip);<br>    options.uri = uri;<br><br>    <span class="hljs-comment">// 3. 设置 Host 头</span><br>    options.headers[<span class="hljs-string">&#x27;Host&#x27;</span>] = host;<br><br>    <span class="hljs-comment">// 4. HTTPS SNI</span><br>    <span class="hljs-keyword">if</span> (uri.isScheme(<span class="hljs-string">&#x27;https&#x27;</span>)) &#123;<br>      (_adapter <span class="hljs-keyword">as</span> IOHttpClientAdapter).onHttpClientCreate = (client) &#123;<br>        client.connectionFactory = (_, __, ___) =&gt;<br>            SecureSocket.startConnect(ip, uri.port, serverName: host);<br>        <span class="hljs-keyword">return</span> client;<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> _adapter.fetch(options, requestStream, cancelFuture);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> close(&#123;<span class="hljs-built_in">bool</span> force = <span class="hljs-keyword">false</span>&#125;) =&gt; _adapter.close(force: force);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-快速接入"><a href="#5-快速接入" class="headerlink" title="5. 快速接入"></a>5. 快速接入</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> dio = Dio()<br>    ..httpClientAdapter = DnsHttpClientAdapter();<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">final</span> res = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.aliyun.com&#x27;</span>);<br>    <span class="hljs-built_in">print</span>(res.data);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Request error: <span class="hljs-subst">$e</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-缓存与降级"><a href="#6-缓存与降级" class="headerlink" title="6. 缓存与降级"></a>6. 缓存与降级</h2><p><a href="https://help.aliyun.com/document_detail/2868007.html?spm=a2c4g.11186623.help-menu-434086.d_3_2_5.7b7d127fbAGSkT">参考官方最佳实践</a></p><h2 id="7-平台差异注意点"><a href="#7-平台差异注意点" class="headerlink" title="7. 平台差异注意点"></a>7. 平台差异注意点</h2><table><thead><tr><th>平台</th><th>注意</th></tr></thead><tbody><tr><td><strong>Android 9+</strong></td><td>默认禁止明文 HTTP，需在 <code>network_security_config.xml</code> 允许 <code>203.107.1.33</code>，或改用 HTTPS 解析节点</td></tr><tr><td><strong>iOS</strong></td><td>ATS 同样限制，建议 HTTPS 节点</td></tr><tr><td><strong>Windows</strong></td><td>无额外限制</td></tr></tbody></table><hr><h2 id="8-性能与安全"><a href="#8-性能与安全" class="headerlink" title="8. 性能与安全"></a>8. 性能与安全</h2><ul><li><strong>并发</strong>：单节点 200 QPS 足够日常 App，如流量大可用多节点 + 本地缓存。  </li><li><strong>HTTPS</strong>：通过 <code>serverName</code> 保留原域名，证书校验正常。  </li><li><strong>安全</strong>：解析节点走 HTTPS 可避免中间人篡改解析结果。</li></ul><hr><h2 id="9-常见问题-FAQ"><a href="#9-常见问题-FAQ" class="headerlink" title="9. 常见问题 FAQ"></a>9. 常见问题 FAQ</h2><table><thead><tr><th>现象</th><th>原因</th><th>解决</th></tr></thead><tbody><tr><td>证书验证失败</td><td>未设置 <code>serverName</code></td><td>示例代码已处理</td></tr><tr><td>连接超时</td><td>本地网络禁止 <code>203.107.1.33</code></td><td>换 HTTPS 节点或配置代理</td></tr><tr><td>返回空字符串</td><td>域名未在阿里云备案</td><td>控制台添加域名</td></tr></tbody></table><hr><h2 id="10-相关文档"><a href="#10-相关文档" class="headerlink" title="10. 相关文档"></a>10. 相关文档</h2><table><thead><tr><th>类别</th><th>地址</th><th>说明</th></tr></thead><tbody><tr><td><strong>HTTP API 接入文档</strong></td><td><a href="https://help.aliyun.com/document_detail/435282.html">https://help.aliyun.com/document_detail/435282.html</a></td><td>直接使用 HTTP&#x2F;HTTPS 接口解析域名（本文方案核心）</td></tr><tr><td><strong>Android SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/150879.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/150879.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 Android SDK 接入指南</td></tr><tr><td><strong>iOS SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/150881.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/150881.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 iOS SDK 接入指南</td></tr><tr><td><strong>鸿蒙 SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/2867709.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/2867709.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 HarmonyOS SDK 快速集成</td></tr><tr><td><strong>Flutter接入移动解析HTTPDNS Android&#x2F;iOS SDK实践方案</strong></td><td><a href="https://help.aliyun.com/zh/dns/httpdns-practice-solution-of-connecting-flutter-to-alibaba-cloud-public-dns-android-ios-sdk">https://help.aliyun.com/zh/dns/httpdns-practice-solution-of-connecting-flutter-to-alibaba-cloud-public-dns-android-ios-sdk</a></td><td>官方另外一份Flutter相关文档（供对比参考）</td></tr><tr><td><strong>Flutter 中自定义DNS解析的实现</strong></td><td><a href="https://blog.csdn.net/zdc9023/article/details/140804093">https://blog.csdn.net/zdc9023/article/details/140804093</a></td><td>CSDN上的一篇相关实现</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>HTTPDNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从架构到源码：一文了解Flutter渲染机制（转载）</title>
    <link href="/2025/08/15/%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%B0%E6%BA%90%E7%A0%81%EF%BC%9A%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <url>/2025/08/15/%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%B0%E6%BA%90%E7%A0%81%EF%BC%9A%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="从架构到源码：一文了解Flutter渲染机制（转载）"><a href="#从架构到源码：一文了解Flutter渲染机制（转载）" class="headerlink" title="从架构到源码：一文了解Flutter渲染机制（转载）"></a>从架构到源码：一文了解Flutter渲染机制（转载）</h1><blockquote><p>**简介：**Flutter从本质上来讲还是一个UI框架，它解决的是一套代码在多端渲染的问题。在渲染管线的设计上更加精简，加上自建渲染引擎，相比ReactNative、Weex以及WebView等方案，具有更好的性能体验。本文将从架构和源码的角度详细分析Flutter渲染机制的设计与实现。较长，同学们可收藏后再看。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-359b40ad8399a1203c5fe639b361e47b_1440w.png" alt="image.png"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>跨平台技术由于其一码多端的生产力提升而表现出巨大的生命力，从早期的Hybrid App到ReactNative&#x2F;Weex、小程序&#x2F;快应用，再到现在的Flutter，跨平台技术一直在解决效率问题的基础上最大化的解决性能和体验问题。这也引出了任何跨平台技术都会面临的核心问题：</p><ul><li>效率：解决在多应用、多平台、多容器上开发效率的问题，一码多端，业务快跑。</li><li>性能：解决的是业务的性能和体验问题。</li></ul><p>效率作为跨平台技术的基本功能，大家都能做到。问题是谁能把性能和体验做得更好，在渲染技术这块一共有三种方案：</p><ul><li>WebView渲染：依赖WebView进行渲染，在功能和性能上有妥协，例如PhoneGap、Cordova、小程序（有的小程序底层也采用了ReactNative等渲染方案）等。</li><li>原生渲染：上层拥抱W3C，通过中间层把前端框架翻译为原生控件，例如ReactNative+React、Weex+Vue的组合，这种方案多了一层转译层，性能上有损耗。随着原生系统的升级，在兼容性上也会有问题。</li><li>自建渲染：自建渲染框架，底层使用<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=Skia&zhida_source=entity">Skia</a>等图形库进行渲染，例如Flutter、Unity。</li></ul><p>Flutter由于其自建渲染引擎，贴近原生的实现方式，获得了优秀的渲染性能。</p><p>Flutter拥有自己的开发工具，开发语言、虚拟机，编译机制，线程模型和渲染管线，和Android相比，它也可以看做一个小型的OS了。</p><p>第一次接触Flutter，可以看看Flutter的创始人Eric之前的访谈《What is Flutter？》，Eric之前致力于Chromium渲染管线的设计与开发，因此Flutter的渲染与Chromium有一定的相似之处，后面我们会做下类比。</p><p>后面我们会从架构和源码的角度分析Flutter渲染机制的设计与实现，在此之前也可以先看看Flutter官方对于渲染机制的分享《How Flutter renders Widgets》。视频+图文的方式会更加直观，可以有一个大体的理解。</p><h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p><img src="https://pic2.zhimg.com/v2-2ea9f2735444827f8de655d722c1f7bf_1440w.png" alt="image.png"></p><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>从结构上看，Flutter渲染由UI Thread与GPU Thread相互配合完成。</p><p>1）UI Thread</p><p>对应图中1-5，执行<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=Dart+VM&zhida_source=entity">Dart VM</a>中的Dart代码（包含应用程序和Flutter框架代码），主要负责Widget Tree、Element Tree、<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=RenderObject+Tree&zhida_source=entity">RenderObject Tree</a>的构建，布局、以及绘制生成绘制指令，生成Layer Tree（保存绘制指令）等工作。</p><p>2）GPU Thread</p><p>对应图中6-7，执行Flutter引擎中图形相关代码（Skia），这个线程通过与GPU通信，获取Layer Tree并执行栅格化以及合成上屏等操作，将Layer Tree显示在屏幕上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">注：图层树（Layer Tree）是Flutter组织绘制指令的方式，类似于Android Rendering里的View DisplayList，都是组织绘制指令的一种方式。<br></code></pre></td></tr></table></figure><p>UI Thread与GPU Thread属于生产者和消费者的角色。</p><h4 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h4><p>我们知道Android上的渲染都是在VSync信号驱动下进行的，Flutter在Android上的渲染也不例外，它会向Android系统注册并等待VSync信号，等到VSync信号到来以后，调用沿着C++ Engine-&gt;Java Engine，到达Dart Framework，开始执行Dart代码，经历Layout、Paint等过程，生成一棵Layer Tree，将绘制指令保存在Layer中，接着进行栅格化和合成上屏。</p><p>具体说来：</p><p><img src="https://pic2.zhimg.com/v2-f96505692019ea265a2a4e29e644f48f_1440w.png" alt="image.png"></p><p>1）向Android系统注册并等待VSync信号</p><p>Flutter引擎启动时，会向Android系统的Choreographer（管理VSync信号的类）注册并接收VSync信号的回调。</p><p>2）接收到VSync信号，通过C++ Engine向Dart Framework发起渲染调用</p><p>当VSync信号产生以后，Flutter注册的回调被调用，VsyncWaiter::fireCallback() 方法被调用，接着会执行 Animator::BeiginFrame()，最终调用到 Window::BeginFrame() 方法，WIndow实例是连接底层Engine和Dart Framework的重要桥梁，基本上与平台相关的操作都会通过Window实例来连接，例如input事件、渲染、无障碍等。</p><p>3）Dart Framework开始在UI线程执行渲染逻辑，生成Layer Tree，并将栅格化任务post到GPU线程执行</p><p>Window::BeiginFrame() 接着调用，执行到 RenderBinding::drawFrame() 方法，这个方法会去驱动UI界面上的dirty节点（需要重绘的节点）进行重新布局和绘制，如果渲染过程中遇到图片，会先放到Worker Thead去加载和解码，然后再放到IO Thread生成图片纹理，由于IO Thread和GPI Thread共享EGL Context，因此IO Thread生成的图片纹理可以被GPU Thread直接访问。</p><p>4）GPU线程接收到Layer Tree，进行栅格化以及合成上屏的工作</p><p>Dart Framework绘制完成以后会生成绘制指令保存在Layer Tree中，通过 Animator::RenderFrame() 把Layer Tree提交给GPU Thread，GPU Thread接着执行栅格化和上屏显示。之后通过 Animator::RequestFrame() 请求接收系统的下一次VSync信号，如此循环往复，驱动UI界面不断更新。</p><p>逐个调用流程比较长，但是核心点没多少，不用纠结调用链，抓住关键实现即可，我们把里面涉及到的一些主要类用颜色分了个类，对着这个类图，基本可以摸清Flutter的脉络。</p><p><img src="https://pic2.zhimg.com/v2-7416f821280caddbf9effbb3c8db5f87_1440w.png" alt="image.png"></p><p>绿色：Widget 黄色：Element 红色：RenderObject</p><p>以上便是Flutter渲染的整体流程，会有多个线程配合，多个模块参与，抛开冗长的调用链，我们针对每一步来具体分析。我们在分析结构时把Flutter的渲染流程分为了7大步，Flutter的timeline也可以清晰地看到这些流程，如下所示：</p><p><img src="https://pic1.zhimg.com/v2-6d075fe2dbbdcad99ff6438477ca90da_1440w.png" alt="image.png"></p><p><strong>UI Thread</strong></p><p>1）Animate</p><p>由 handleBeiginFrame() 方法的transientCallbacks触发，如果没有动画，则该callback为空；如果有动画，则会回调 Ticker.tick() 触发动画Widget更新下一帧的值。</p><p>2）Build</p><p>由 BuildOwner.buildScope() 触发，主要用来构建或者更新三棵树，Widget Tree、Element Tree和RenderObject Tree。</p><p>3）Layout</p><p>由 PipelineOwner.flushLayout() 触发，它会调用 RenderView.performLayout()，遍历整棵Render Tree，调用每个节点的 layout()，根据build过程记录的信息，更新dirty区域RenderObject的排版数据，使得每个RenderObject最终都能有正确的大小（size）和位置（position，保存在parentData中）。</p><p>4）Compositing Bits</p><p>由 PipelineOwner.flushCompositingBits() 触发，更新具有dirty合成位置的渲染对象，此阶段每个渲染对象都会了解其子项是否需要合成，在绘制阶段使用此信息选择如何实现裁剪等视觉效果。</p><p>5）Paint</p><p>由 PipeOwner.flushPaint() 触发，它会调用 RenderView.paint()。最终触发各个节点的 paint()，最终生成一棵Layer Tree，并把绘制指令保存在Layer中。</p><p>6）Submit（Compositing）</p><p>由 renderView.compositeFrame() 方法触发，这个地方官方的说法叫Compositing，不过我觉得叫Compositing有歧义，因为它并不是在合成，而是把Layer Tree提交给GPU Thread，因而我觉得叫Submit更合适。</p><p><strong>GPU Thread</strong></p><p>7）Compositing</p><p>由 Render.compositeFrame() 触发，它通过Layer Tree构建一个Scene，传给Window进行最终的光栅化。</p><p>GPU Thread通过Skia向GPU绘制一帧数据，GPU将帧信息保存在FrameBuffer里，然后根据VSync信号周期性的从FrameBuffer取出帧数据交给显示器，从而显示出最终的界面。</p><h3 id="Rendering-Pipeline"><a href="#Rendering-Pipeline" class="headerlink" title="Rendering Pipeline"></a>Rendering Pipeline</h3><p>Flutter引擎启动时，向Android系统的Choreographer注册并接收VSync信号，GPU硬件产生VSync信号以后，系统便会触发回调，并驱动UI线程进行渲染工作。</p><h4 id="1-Animate"><a href="#1-Animate" class="headerlink" title="1 Animate"></a>1 Animate</h4><p>触发方法：由 handleBeiginFrame() 方法的transientCallbacks触发</p><p>Animate在 handleBeiginFrame() 方法里由transientCallbacks触发，如果没有动画，则该callback为空；如果有动画，则会回调 Ticker._tick() 触发动画Widget更新下一帧的值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">void handleBeginFrame(Duration rawTimeStamp) &#123;<br>    ...<br>    try &#123;<br>      // TRANSIENT FRAME CALLBACKS<br>      Timeline.startSync(&#x27;Animate&#x27;, arguments: timelineWhitelistArguments);<br>      _schedulerPhase = SchedulerPhase.transientCallbacks;<br>      final Map&lt;int, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;<br>      _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;;<br>      callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123;<br>        if (!_removedIds.contains(id))<br>          _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);<br>      &#125;);<br>      ...<br>    &#125; finally &#123;<br>      ...<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>handleBeiginFrame() 处理完成以后，接着调用 handleDrawFrame()，handleDrawFrame() 会触发以下回调：</p><ul><li>postFrameCallbacks用来通知监听者绘制已经完成。</li><li>pesistentCallbacks用来触发渲染。</li></ul><p>这两个回调都是SchedulerBinding内部的回调队列，如下所示：</p><ul><li>_transientCallbacks：用于存放一些临时回调，目前是在 Ticker.scheduleTick() 中注册，用来驱动动画。</li><li>_persistentCallbacks：用来存放一些持久回调，不能在此回调中再请求新的绘制帧，持久回调一经注册就不嫩嫩移除， RenderBinding.initInstaces().addPersitentFrameCallback() 添加了一个持久回调，用来触发 drawFrame()。</li><li>_postFrameCallbacks：在Frame结束时会被调用一次，调用后会被移除，它主要是用来通知监听者这个Frame已经完成。</li></ul><p>接着会调用 WidgetBinder.drawFrame() 方法，它会先调用会先调用 BuildOwner.buildScope() 触发树的更新，然后才进行绘制。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">@override<br>void drawFrame() &#123;<br>  ...<br>  try &#123;<br>    if (renderViewElement != null)<br>      buildOwner.buildScope(renderViewElement);<br>    super.drawFrame();<br>    buildOwner.finalizeTree();<br>  &#125; finally &#123;<br>    assert(() &#123;<br>      debugBuildingDirtyElements = false;<br>      return true;<br>    &#125;());<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用 RenderingBinding.drawFrame() 触发layout、paingt等流程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">void drawFrame() &#123;<br>  assert(renderView != null);<br>  pipelineOwner.flushLayout();<br>  pipelineOwner.flushCompositingBits();<br>  pipelineOwner.flushPaint();<br>  if (sendFramesToEngine) &#123;<br>    renderView.compositeFrame(); // this sends the bits to the GPU<br>    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.<br>    _firstFrameSent = true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上便是核心流程代码，我们接着来Build的实现。</p><h4 id="2-Build"><a href="#2-Build" class="headerlink" title="2 Build"></a>2 Build</h4><p>触发方法：由 BuildOwner.buildScope() 触发。</p><p>我们上面说到，handleDrawFrame() 会触发树的更新，事实上 BuildOwner.buildScope() 会有两种调用时机：</p><ul><li>树构建（应用启动时）：我们上面提到的 runApp() 方法调用的 scheduleAttachRootWidget() 方法，它会构建Widgets Tree、Element Tree与RenderObject Tree三棵树。</li><li>树更新（帧绘制与更新时）：这里不会重新构建三棵树，而是只会更新dirty区域的Element。</li></ul><p>也即是说树的构建和更新都是由 BuildOwner.buildScope() 方法来完成的。它们的差别在于树构建的时候传入了一个 element.mount(null, null) 回调。在 buildScope() 过程中会触发这个回调。</p><p>这个回调会构建三棵树，为什么会有三棵树呢，因为Widget只是对UI元素的一个抽象描述，我们需要先将其inflate成Element，然后生成对应的RenderObject来驱动渲染，如下所示：</p><ul><li>Widget Tree：为Element描述需要的配置，调用createElement方法创建Element，决定Element是否需要更新。Flutter通过查分算法比对Widget树前后的变化，来决定Element的State是否改变。</li><li>Element Tree：表示Widget Tree特定位置的一个实例，调用createRenderObject创建RenderObject，同时持有Widget和RenderObject，负责管理Widget的配置和RenderObjec的渲染。Element的状态由Flutter维护，开发人员只需要维护Widget即可。</li><li>RenderObject Tree：RenderObject绘制，测量和绘制节点，布局子节点，处理输入事件。</li></ul><h4 id="3-Layout"><a href="#3-Layout" class="headerlink" title="3 Layout"></a>3 Layout</h4><p>触发方法：由 PipelineOwner.flushLayout() 触发。</p><ul><li>相关文档：Understanding constraints</li><li>相关源码：PipelineOwner.flushLayout()</li></ul><p>Layout是基于单向数据流来实现的，父节点向子节点传递约束（Constraints），子节点向父节点传递大小（Size，保存在父节点的parentData变量中）。先深度遍历RenderObject Tree，然后再递归遍历约束。单向数据流让布局流程变得更简单，性能也更好。</p><p><img src="https://picx.zhimg.com/v2-702e4335e17edc01448263c0d9ac3f1d_1440w.png" alt="image.png"></p><p>对于RenderObject而言，它只是提供了一套基础的布局协议，没有定义子节点模型、坐标系统和具体的布局协议。它的子类RenderBox则提供了一套笛卡尔坐标体系（和Android&amp;iOS一样），大部分RenderObject类都是直接继承RenderBox来实现的。RenderBox有几个不同的子类实现，它们各自对应了不同的布局算法。</p><ul><li>RenderFlex：弹性布局，这是一种很常见的布局方式，它对应的是Widget组件Flex、Row和Column。关于这一块的布局算法代码注释里有描述，也可以直接看这篇文章的解释。</li><li>RenderStack：栈布局。</li></ul><p>我们再来聊聊Layout流程中涉及的两个概念边界约束（Constraints）和重新布局边界（RelayoutBoundary）。</p><blockquote><p>边界约束（Constraints）：边界约束是父节点用来限制子节点的大小的一种方式，例如BoxConstraints、SliverConstraints等。</p></blockquote><p>RenderBox提供一套BoxConstraints，如图所示，它会提供以下限制：</p><ul><li>minWidth</li><li>maxWidth</li><li>minHeight</li><li>maxHeight</li></ul><p>利用这种简单的盒模型约束，我们可以非常灵活的实现很多常见的布局，例如完全和父节点一样的大小，垂直布局（宽度和父节点一样大）、水平布局（高度和父容器一样大）。</p><p>通过Constraints和子节点自己配置的大小信息，就可以最终算出子节点的大小，接下来就需要计算子节点的位置。子节点的位置是由父节点来决定的。</p><blockquote><p>重新布局边界（RelayoutBoundary）：为一个子节点设置重新布局边界，这样当它的大小发生变化时，不会导致父节点重新布局，这是个标志位，在标记dirty的markNeedsLayout()方法中会检查这个标记位来决定是否重新进行布局。</p></blockquote><p>重新布局边界这种机制提升了布局排版的性能。</p><p>通过Layout，我们了解了所有节点的位置和大小，接下来就会去绘制它们。</p><h4 id="4-Compositing-Bits"><a href="#4-Compositing-Bits" class="headerlink" title="4 Compositing Bits"></a>4 Compositing Bits</h4><p>触发方法：由 PipelineOwner.flushCompositingBits() 触发。</p><p>在Layout之后，在Paint之前会先执行Compositing Bits，它会检查RenderObject是否需要重绘，然后更新RenderObject Tree各个节点的needCompositing标志。如果为true，则需要重绘。</p><h4 id="5-Paint"><a href="#5-Paint" class="headerlink" title="5 Paint"></a>5 Paint</h4><p>触发方法：由 PipeOwner.flushPaint() 触发。</p><p>相关源码：</p><ul><li>Dart层调用入口：painting.dart</li><li>C++层实现：<a href="https://link.zhihu.com/?target=http://canvas.cc">http://canvas.cc</a></li></ul><p>我们知道现代的UI系统都会进行界面的图层划分，这样可以进行图层复用，减少绘制量，提升绘制性能，因此Paint（绘制）的核心问题还是解决绘制命令应该放到哪个图层的问题。</p><p><img src="https://pica.zhimg.com/v2-07f93a0590850e6357057cd9030263c2_1440w.png" alt="image.png"></p><p>Paint的过程也是单向数据流，先向下深度遍历RenderObject Tree，再递归遍历子节点，遍历的过程中会决定每个子节点的绘制命令应该放在那一层，最终生成Layer Tree。</p><p>和Layout一样，为了提到绘制性能，绘制阶段也引入了重新绘制边界。</p><blockquote><p>重新绘制边界（<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=RepaintBoundary&zhida_source=entity">RepaintBoundary</a>）：为一个子节点设置重新绘制边界，这样当它需要重新绘制时，不会导致父节点重新绘制，这是个标志位，在标记dirty的markNeedsPaint()方法中会检查这个标记位来决定是否重新进行重绘。</p></blockquote><p>事实上这种重绘边界的机制相对于把图层分层这个功能开放给了开发者，开发者可以自己决定自己的页面那一块在重绘时不参与重绘（例如滚动容器），以提升整体页面的性能。重新绘制边界会改变最终的图层树（Layer Tree）结构。</p><p>当然这些重绘边界并不都需要我们手动放置，大部分Widget组件会自动放置重绘边界（自动分层）。</p><p>设置了RepaintBoundary的就会额外生成一个图层，其所有的子节点都会被绘制在这个新的图层上，Flutter中使用图层来描述一个层次上（一个绘制指令缓冲区）的所有RenderObject，根节点的RenderView会创建Root Layer，并且包含若干个子Layer，每个Layer又包含多个RenderObject，这些Layer便形成了一个Layer Tree。每个RenderObject在绘制时，会产生相关的绘制指令和绘制参数，并保存在对应的Layer上。</p><p>相关Layer都继承Layer类，如下所示：</p><ul><li>ClipRectLayer：矩形裁剪层，可以指定裁剪和矩形行为参数。共有4种裁剪行为，none、hardEdge、antiAlias、antiAliashWithSaveLayer。</li><li>ClipRRectLayer：圆角矩形裁剪层，行为同上。</li><li>ClipPathLayer：路径裁剪层，可以指定路径和行为裁剪参数，行为同上。</li><li>OpacityLayer：透明层，可以指定透明度和偏移（画布坐标系原点到调用者坐标系原点的偏移）参数。</li><li>ShaderMaskLayer：着色层，可以指定着色器矩阵和混合模式参数。</li><li>ColorFilterLayer：颜色过滤层，可以指定颜色和混合模式参数。</li><li>TransformLayer：变换图层，可以指定变换矩阵参数。</li><li>BackdropFilterLayer：背景过滤层，可以指定背景图参数。</li><li>PhysicalShapeLayer：物理性状层，可以指定颜色等八个参数。</li></ul><p>具体可以参考文章上方的Flutter类图。</p><p>聊完了绘制的基本概念，我们再来看看绘制的具体流程，上面提到渲染第一帧的时候，会从根节点RenderView开始，逐个遍历所有子节点进行操作。如下所示：</p><p>1）创建Canvas对象</p><p>Canvas对象通过PaintCotext获取，它内部会创建一个PictureLayer，并通过ui.PictureRecorder调用到C++层创建一个Skia的SkPictureRecorder的实例，并通过SkPictureRecorder创建SkCanvas，而后将SkCanvas返回给Dart Framework使用。SkPictureRecorder可以用来记录生成的绘制命令。</p><p>2）通过Canvas执行绘制</p><p>绘制命令会被SkPictureRecorder记录下来。</p><p>3）通过Canvas结束绘制，准备进行栅格化</p><p>绘制结束后，会调用 Canvas.stopRecordingIfNeeded() 方法，它会接着去调用C++层的SkPictureRecorder::endRecording()方法生成一个Picture对象并保存在PictureLayer中，Picture对象包含了所有的绘制指令。所有的Layer绘制完成，形成Layer Tree。</p><p>绘制完成以后，接着就可以向GPU Thread提交Layer Tree了。</p><h4 id="6-Submit（Compositing）"><a href="#6-Submit（Compositing）" class="headerlink" title="6 Submit（Compositing）"></a>6 Submit（Compositing）</h4><p>触发方法：由 renderView.compositeFrame() 方法触发。</p><ul><li>Dart层调用入口：compositing.dart widow.dart</li><li>C++层实现：<a href="https://link.zhihu.com/?target=http://scene.cc">http://scene.cc</a><a href="https://link.zhihu.com/?target=http://scene_builder.cc">http://scene_builder.cc</a></li></ul><blockquote><p>注：这个地方官方的说法叫Compositing，不过我觉得叫Compositing有歧义，因为它并不是在合成，而是把Layer Tree提交给GPU Thread，因而我觉得叫Submit更合适。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">void compositeFrame() &#123;<br>    Timeline.startSync(&#x27;Compositing&#x27;, arguments: timelineArgumentsIndicatingLandmarkEvent);<br>    try &#123;<br>      final ui.SceneBuilder builder = ui.SceneBuilder();<br>      final ui.Scene scene = layer.buildScene(builder);<br>      if (automaticSystemUiAdjustment)<br>        _updateSystemChrome();<br>      _window.render(scene);<br>      scene.dispose();<br>      assert(() &#123;<br>        if (debugRepaintRainbowEnabled || debugRepaintTextRainbowEnabled)<br>          debugCurrentRepaintColor = debugCurrentRepaintColor.withHue((debugCurrentRepaintColor.hue + 2.0) % 360.0);<br>        return true;<br>      &#125;());<br>    &#125; finally &#123;<br>      Timeline.finishSync();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>创建SceneBuilder对象，并通过 SceneBuilder.addPicture() 将上文中生成的Picture添加到SceneBuilder对象对象中。</li><li>通过 SceneBuilder.build() 方法生成Scene对象，接着会通过window.render(scene)将包含绘制指令的Layer Tree提交给CPU线程进行光栅化和合成。</li></ul><p>在这个过程中Dart Framework层的Layer会被转换为C++层使用的flow::layer，Flow模块是一个基于Skia的简单合成器，运行在GPU线程，并向Skia上传指令信息。Flutter Engine使用flow缓存Paint阶段生成的绘制指令和像素信息。我们在Paint阶段的Layer，它们都与Flow模块里的Layer一一对应。</p><p><img src="https://pic1.zhimg.com/v2-682316d05b941b90d89cffe1749ad436_1440w.png" alt="image.png"></p><h3 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h3><h4 id="7-Raster-Compositing"><a href="#7-Raster-Compositing" class="headerlink" title="7 Raster&amp;Compositing"></a>7 Raster&amp;Compositing</h4><p>有了包含渲染指令的Layer Tree以后就可以进行光栅化和合成了。</p><blockquote><p>光栅化是把绘制指令转换成对应的像素数据，合成是把各图层栅格化后的数据进行相关的叠加和特性处理。这个流程称为Graphics Pipeline。</p></blockquote><p>相关代码：<a href="https://link.zhihu.com/?target=http://rasterizer.cc">http://rasterizer.cc</a></p><p>Flutter采用的是同步光栅化。什么是同步光栅化？</p><p>同步光栅化：</p><blockquote><p>光栅化和合成在一个线程，或者通过线程同步等方式来保证光栅化和合成的的顺序。</p></blockquote><p>直接光栅化：直接执行可见图层的DisplayList中可见区域的绘制指令进行光栅化，在目标Surface的像素缓冲区上生成像素的颜色值。<br>间接光栅化：为指定图层分配额外的像素缓冲区（例如Android提供View.setLayerType允许应用为指定View提供像素缓冲区，Flutter提供了Relayout Boundary机制来为特定图层分配额外缓冲区），该图层光栅化的过程中会先写入自身的像素缓冲区，渲染引擎再将这些图层的像素缓冲区通过合成输出到目标Surface的像素缓冲区。</p><p>异步分块光栅化：</p><blockquote><p>图层会按照一定的规则粉尘同样大小的图块，光栅化以图块为单位进行，每个光栅化任务执行图块区域内的指令，将执行结果写入分块的像素缓冲区，光栅化和合成不在一个线程内执行，并且不是同步的。如果合成过程中，某个分块没有完成光栅化，那么它会保留空白或者绘制一个棋盘格图形。</p></blockquote><p>Android和Flutter采用同步光栅化策略，以直接光栅化为主，光栅化和合成同步执行，在合成的过程中完成光栅化。而Chromium采用异步分块光栅化测量，图层会进行分块，光栅化和合成异步执行。</p><p>从文章上方的序列图可以看到，光栅化的入口是 Rasterizer::DoDraw() 方法。它会接着调用 ScopedFrame::Raster() 方法，这个方法就是光栅化的核心实现，它主要完成以下工作：</p><ul><li>LayerTree::Preroll()：处理绘制前的一些准备工作。</li><li>LayerTree::Paint()：嵌套调用不通Layer的绘制方法。</li><li>SkCanvas::Flush()：将数据flush给GPU。</li><li>AndroidContextGL::SwapBuffers()：交换帧缓存给显示器显示。</li></ul><p>到这里我们Flutter整体的渲染实现我们就分析完了。</p><h3 id="Android、Chromium与Flutter"><a href="#Android、Chromium与Flutter" class="headerlink" title="Android、Chromium与Flutter"></a>Android、Chromium与Flutter</h3><p>Android、Chromium、Flutter都作为Google家的明星级项目，它们在渲染机制的设计上既有相似又有不同，借着这个机会我们对它们做个比较。</p><p>现代渲染流水线的基本设计：</p><p><img src="https://pic2.zhimg.com/v2-e8daeb51487d19fdcb37b964e4a7c25b_1440w.png" alt="image.png"></p><p>我们再分别来看看Android、Chromium和Flutter是怎么实现的。</p><p>Android渲染流水线：</p><p><img src="https://picx.zhimg.com/v2-9a33c28c7e3bda157ebf057a8607b3cb_1440w.png" alt="image.png"></p><p>Chromium渲染流水线：</p><p><img src="https://pic4.zhimg.com/v2-39daae787aa59f92d7d10bee00851a9b_1440w.png" alt="image.png"></p><p>Flutter渲染流水线：</p><p><img src="https://pic3.zhimg.com/v2-649010987227d1392f589d601cbc727a_1440w.png" alt="image.png"></p><p>相互比较：</p><p><img src="https://pic3.zhimg.com/v2-cd3655c9b26665ef5aa872d66cadbbae_1440w.png" alt="image.png"></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最后的最后，谈一谈我对跨平台生态的理解。</p><p>跨平台容器生态至少可以分为三个方面：</p><p><img src="https://pic2.zhimg.com/v2-efe0e18902da772089e4e8080bc10429_1440w.png" alt="image.png"></p><h4 id="前端框架生态"><a href="#前端框架生态" class="headerlink" title="前端框架生态"></a>前端框架生态</h4><p>前端框架生态直接面向的是业务，它应该具备两个特点：</p><ul><li>拥抱W3C生态</li><li>相对稳定性</li></ul><p>它应该是拥抱W3C生态的。W3C生态是一个繁荣且充满活力的生态，它会发展的更久更远。试图抛弃W3C生态，自建子集的做法很难走的长远。这从微信小程序、Flutter都推出for web系列就能看出端倪。</p><p>它应该是相对稳定的。不能说我们每换一套容器，前端的业务就需要重新写一遍，例如我们之前做H5容器，后来做小程序容器，因为DSL不通，前端要花大力气将业务重写。虽然小程序是一码多端，但是我认为这并没有解决效率问题，主要存在两个问题：</p><ul><li>前端的学习成本增加，小程序的DSL还算简单，Flutter的Widget体系学习起来就需要花上一点时间，这些对于团队来说都是成本。</li><li>业务代码重写，大量逻辑需要梳理，而且老业务并不一定都适合迁移到新容器上，比如小程序本来就是个很轻量的解决方案，但是我们在上面堆积了很多功能，造成了严重的体验问题。</li></ul><p>在这种情况下，业务很难实现快速奔跑。所以说不管底层容器怎么变，前端的框架一定是相对稳定的。而这种稳定性就有赖于容器统一层。</p><h4 id="容器统一层"><a href="#容器统一层" class="headerlink" title="容器统一层"></a>容器统一层</h4><p>容器统一层是在前端框架和容器层之间的一个层级。它定义了容器提供的基本能力，这些能力就像协议一样，是相对稳定的。</p><p>协议是非常重要的，就像OpenGL协议一样，有了OpenGL协议，不管底层的渲染方案如何实现，上层的调用是不用变的。对于我们的业务也是一样，围绕着容器统一层，我们需要沉淀通用的解决方案。</p><ul><li>统一API解决方案</li><li>统一性能解决方案</li><li>统一组件解决方案</li><li>统一配套设施解决方案</li><li>等等</li></ul><p>这些东西不能说每搞一套容器，我们都要大刀阔斧重来一遍，这种做法是有问题的。已经做过的东西，遇到新的技术就推倒重来，只能说明以前定义的方案考虑不周全，没有考虑沉淀统一和扩展的情况。</p><p>如果我们自顾自的一遍遍做着功能重复的技术方案，业务能等着我们吗。</p><h4 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h4><p>容器层的迭代核心是为了在解决效率问题的基础上最大化的解决性能和体验问题。</p><p>早期的ReactNative模式解决了效率了问题，但是多了一个通信层（ReactNative是依靠将虚拟DOM的信息传递给原生，然后原生根据这些布局信息构建对应的原生控件树来实现的原生渲染）存在性能问题，而且这种转译的方式需要适配系统版本，带来更多的兼容性问题。</p><p>微信后续又推出了小程序方案，在我看来，小程序方案不像是一个技术方案，它更像是一个商业解决方案，解决了平台大流量规范管理和分发的问题，给业务方提供通用的技术解决方案，当然小程序底层的渲染方案也是多种多样的。</p><p>后起之秀Flutter解决的痛点是性能能力，它自建了一套GUI系统，底层直接调用Skia图形库进行渲染（与Android的机制一样），进而实现了原生渲染。但是它基于开发效率、性能以及自身生态等因素的考虑最终选择了Dart，这种做法无疑是直接抛弃了繁荣的前端生态，就跨平台容器的发展历史来看，在解决效率与性能的基础上，最大化的拥抱W3C生态，可能是未来最好的方向。Flutter目前也推出了Flutter for Web，从它的思路来看，是先打通Android与iOS，再逐步向Web渗透，我们期待它的表现。</p><p>容器技术是动态向前发展的，我们今年搞Flutter，明年可能还会搞其他技术方案。在方案变迁的过程中，我们需要保证业务快速平滑的过度，而不是每次大刀阔斧的再来一遍。</p><p>随着手机性能的提升，WebView的性能也越来越好，Flutter又为解决性能问题提供了新的思路，一个基础设施完善，体验至上，一码多端的跨平台容器生态值得期待。</p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>欢迎加入本地生活终端技术部！</p><p>本地生活终端技术部隶属于阿里本地生活用户技术部，从事客户端技术研发工作，主要负责本地生活饿了么App 和 口碑App 的客户端架构、基础中间件、跨平台技术解决方案，以及账号、首页、全局购物车、收银台、订单列表、红包卡券、直播、短视频等平台化核心业务链路。目前团队规模50+人，我们依托阿里强大的终端技术底盘，以及本地生活的业务土壤，致力于打造最优秀的O2O技术团队。</p><p>招聘本地生活-客户端开发专家&#x2F;高级技术专家-杭州&#x2F;上海&#x2F;北京，欢迎您的加盟！简历发送至 <a href="mailto:&#119;&#x75;&#115;&#104;&#x69;&#64;&#x61;&#x6c;&#x69;&#98;&#x61;&#x62;&#97;&#45;&#105;&#x6e;&#x63;&#46;&#x63;&#x6f;&#x6d;">wushi@alibaba-inc.com</a></p><blockquote><p>附录</p></blockquote><p>相关平台<br>[1]Flutter pub.dev<br>（<a href="https://link.zhihu.com/?target=https://pub.dev/flutter/packages">https://pub.dev/flutter/packages</a>）<br>相关文档<br>[1]Flutter 官方文档<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/get-started/install/macos">https://flutter.dev/docs/get-started/install/macos</a>）<br>[2]Flutter for Android developers<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/get-started/flutter-for/android-devs">https://flutter.dev/docs/get-started/flutter-for/android-devs</a>）<br>[3]Flutter Widget Doc<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/reference/widgets">https://flutter.dev/docs/reference/widgets</a>）<br>[4]Flutter API Doc（<a href="https://link.zhihu.com/?target=https://api.flutter.dev/">https://api.flutter.dev/</a>）<br>[5]Dart Doc<br>（<a href="https://link.zhihu.com/?target=https://dart.dev/guides/language">https://dart.dev/guides/language</a>）<br>相关源码<br>[1]Dart Framework<br>（<a href="https://link.zhihu.com/?target=https://github.com/flutter/flutter/tree/master/packages">https://github.com/flutter/flutter/tree/master/packages</a>）<br>[2]Flutter Engine<br>（<a href="https://link.zhihu.com/?target=https://github.com/flutter/engine">https://github.com/flutter/engine</a>）<br>相关资源<br>[1]Flutter Render Pipeline<br>（<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=UUfXWzp0-DU">https://www.youtube.com/watch?v=UUfXWzp0-DU</a>）<br>[2]How Flutter renders Widgets<br>（<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=996ZgFRENMs">https://www.youtube.com/watch?v=996ZgFRENMs</a>）<br>[3]深入了解Flutter的高性能图形渲染 video<br>（<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av48772383">https://www.bilibili.com/video/av48772383</a>）<br>[4]深入了解Flutter的高性能图形渲染 ppt<br>（<a href="https://link.zhihu.com/?target=https://files.flutter-io.cn/events/gdd2018/Deep_Dive_into_Flutter_Graphics_Performance.pdf">https://files.flutter-io.cn/events/gdd2018/Deep_Dive_into_Flutter_Graphics_Performance.pdf</a>）</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Firebase Flutter项目实践</title>
    <link href="/2025/08/15/Google-Firebase-Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/08/15/Google-Firebase-Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Google-Firebase-Flutter项目实践"><a href="#Google-Firebase-Flutter项目实践" class="headerlink" title="Google Firebase Flutter项目实践"></a>Google Firebase Flutter项目实践</h1><h2 id="Crashlytics"><a href="#Crashlytics" class="headerlink" title="Crashlytics"></a>Crashlytics</h2><blockquote><p>这是我们的报错统计插件，非常实用的一个插件，可以监测到你在线上的崩溃和错误 ❌ 问题，类似于Bugly功能。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在 Flutter 项目中<a href="https://firebase.google.com/docs/flutter/setup?authuser=0">配置并初始化 Firebase</a>（如果尚未执行此操作）。</p></li><li><p><strong>建议做法</strong>：如需使用“未遇到崩溃问题的用户”、“面包屑导航日志”和“疾速崩溃提醒”等功能，您需要在 Firebase 项目中启用 Google Analytics（分析）。</p><p>Crashlytics 支持的所有 Android 和 Apple 平台（watchOS 除外）都可以利用 Google Analytics（分析）中的这些功能。</p><p>确保您的 Firebase 项目中启用了 Google Analytics（分析）：前往 settings &gt;“项目设置”&gt;“集成”标签页，然后按照 Google Analytics（分析）对应的屏幕上的说明进行操作。</p></li></ol><h2 id="第-1-步：将-Crashlytics-添加到您的-Flutter-项目"><a href="#第-1-步：将-Crashlytics-添加到您的-Flutter-项目" class="headerlink" title="第 1 步：将 Crashlytics 添加到您的 Flutter 项目"></a><strong>第 1 步</strong>：将 Crashlytics 添加到您的 Flutter 项目</h2><ol><li><p>从 Flutter 项目的根目录运行以下命令，安装 Crashlytics Flutter 插件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter pub add firebase_crashlytics<br></code></pre></td></tr></table></figure></li><li><p>从 Flutter 项目的根目录运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutterfire configure<br></code></pre></td></tr></table></figure><p>运行此命令可确保您的 Flutter 应用的 Firebase 配置是最新的，对于 Android，还会向您的应用添加所需的 Crashlytics Gradle 插件。</p></li><li><p>完成后，重新构建您的 Flutter 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter run<br></code></pre></td></tr></table></figure></li></ol><h2 id="第-2-步：配置崩溃处理程序"><a href="#第-2-步：配置崩溃处理程序" class="headerlink" title="第 2 步：配置崩溃处理程序"></a><strong>第 2 步</strong>：配置崩溃处理程序</h2><p>您可以使用 <code>FirebaseCrashlytics.instance.recordFlutterFatalError</code> 替换 <code>FlutterError.onError</code>，自动捕获 Flutter 框架中抛出的所有错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  WidgetsFlutterBinding.ensureInitialized();<br><br>  <span class="hljs-keyword">await</span> Firebase.initializeApp();<br><br>  <span class="hljs-comment">// Pass all uncaught errors from the framework to Crashlytics.</span><br>  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;<br><br>  runApp(MyApp());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您使用区域 (zone)，则对区域的错误处理程序进行插桩 (instrument) 后，系统将捕获 Flutter 框架（例如，在按钮的 <code>onPressed</code> 处理程序中）未捕获的错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  runZonedGuarded&lt;Future&lt;<span class="hljs-keyword">void</span>&gt;&gt;(() <span class="hljs-keyword">async</span> &#123;<br>    WidgetsFlutterBinding.ensureInitialized();<br>    <span class="hljs-keyword">await</span> Firebase.initializeApp();<br><br>    FlutterError.onError =<br>       FirebaseCrashlytics.instance.recordFlutterFatalError;<br><br>    runApp(MyApp());<br>  &#125;, (error, stack) =&gt;<br>    FirebaseCrashlytics.instance.recordError(error, stack, fatal: <span class="hljs-keyword">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>如需查看有关如何处理其他类型错误的示例，请参阅<a href="https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=flutter&authuser=0">自定义崩溃报告</a>。</p><h2 id="第-3-步：强制造成一次测试崩溃以完成设置"><a href="#第-3-步：强制造成一次测试崩溃以完成设置" class="headerlink" title="第 3 步：强制造成一次测试崩溃以完成设置"></a><strong>第 3 步</strong>：强制造成一次测试崩溃以完成设置</h2><p>如需完成 Crashlytics 设置并在 Firebase 控制台的 Crashlytics 信息中心内查看初始数据，您需要强制抛出一个测试异常。</p><ol><li><p>向您的应用添加可用于强制抛出测试异常的代码。</p><p>如果您添加了一个对顶级 <code>Zone</code> 调用 <code>FirebaseCrashlytics.instance.recordError(error, stack, fatal: true)</code> 的错误处理程序，可以使用以下代码向应用添加一个按下即会抛出测试异常的按钮：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">TextButton(<br>    onPressed: () =&gt; <span class="hljs-keyword">throw</span> Exception(),<br>    child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;Throw Test Exception&quot;</span>),<br>),<br></code></pre></td></tr></table></figure></li><li><p>构建并运行您的应用。</p></li><li><p>强制抛出测试异常，以便发送您的应用的第一个报告：</p><ol><li>在测试设备或模拟器上打开应用。</li><li>在您的应用中，按下您使用上述代码添加的测试异常按钮。</li></ol></li><li><p>前往 Firebase 控制台的 <a href="https://console.firebase.google.com/project/_/crashlytics?authuser=0">Crashlytics 信息中心</a>，查看您的测试崩溃报告。</p><p>如果您已刷新控制台，但在五分钟后仍未看到测试崩溃报告，请<a href="https://firebase.google.com/docs/crashlytics/test-implementation?authuser=0#enable-debug-logging">启用调试日志记录</a>，查看您的应用是否正在发送崩溃报告。</p></li></ol><p>大功告成！Crashlytics 现在会监控您的应用是否发生崩溃，以及 Android 中的非严重错误和 ANR。您可以访问 <a href="https://console.firebase.google.com/project/_/crashlytics?authuser=0">Crashlytics 信息中心</a>，查看和调查所有报告和统计信息。</p><h2 id="实际体验问题"><a href="#实际体验问题" class="headerlink" title="实际体验问题"></a>实际体验问题</h2><ul><li>公司wifi网络情况下，上报接口异常</li><li>蜂窝网络情况下，启动时候上报正常，使用期间上报接口异常</li><li>蜂窝网络情况下，手机蓝灯app开代理，启动时候上报正常，使用期间上报接口正常</li></ul><blockquote><p><a href="https://firebaselogging-pa.googleapis.com/v1/firelog/legacy/batchlog">https://firebaselogging-pa.googleapis.com/v1/firelog/legacy/batchlog</a><br>Status Code: 200</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>架构</tag>
      
      <tag>Google</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
