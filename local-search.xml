<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案</title>
    <link href="/2025/08/19/Dio-%E9%98%BF%E9%87%8C%E4%BA%91-HTTPDNS%EF%BC%88HTTP-API%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9B%B4%E8%BF%9E%E6%96%B9%E6%A1%88/"/>
    <url>/2025/08/19/Dio-%E9%98%BF%E9%87%8C%E4%BA%91-HTTPDNS%EF%BC%88HTTP-API%EF%BC%89%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9B%B4%E8%BF%9E%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Dio-阿里云-HTTPDNS（HTTP-API）实现跨平台动态域名解析直连方案"><a href="#Dio-阿里云-HTTPDNS（HTTP-API）实现跨平台动态域名解析直连方案" class="headerlink" title="Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案"></a>Dio + 阿里云 HTTPDNS（HTTP API）实现跨平台动态域名解析直连方案</h1><blockquote><p>纯 Dart 实现，支持 <strong>Android &#x2F; iOS &#x2F; Windows</strong>，零平台通道、零 SDK 依赖。</p></blockquote><hr><h2 id="1-背景与目标"><a href="#1-背景与目标" class="headerlink" title="1. 背景与目标"></a>1. 背景与目标</h2><table><thead><tr><th>需求</th><th>说明</th></tr></thead><tbody><tr><td>跨平台</td><td>Android &#x2F; iOS &#x2F; Windows 三端共用一份代码</td></tr><tr><td>不引入官方 SDK</td><td>仅使用阿里云 HTTPDNS 的 <strong>HTTP API</strong></td></tr><tr><td>网络库</td><td>Flutter &#x2F; Dart 的 <strong>Dio</strong></td></tr><tr><td>最终效果</td><td>请求时自动把域名解析成 IP，再以 IP 直连，解决 DNS 劫持、时延等问题</td></tr></tbody></table><hr><h2 id="2-阿里云-HTTPDNS-HTTP-API-速查"><a href="#2-阿里云-HTTPDNS-HTTP-API-速查" class="headerlink" title="2. 阿里云 HTTPDNS HTTP API 速查"></a>2. 阿里云 HTTPDNS HTTP API 速查</h2><table><thead><tr><th>字段</th><th>示例</th></tr></thead><tbody><tr><td>解析节点</td><td><code>http://203.107.1.33</code> 或 <code>https://203.107.1.33</code></td></tr><tr><td>固定前缀</td><td><code>/&#123;Your_Account_ID&#125;</code></td></tr><tr><td>查询参数</td><td><code>host=www.example.com</code></td></tr><tr><td>返回</td><td><strong>纯文本</strong> 单 IPv4 地址，失败为空或 <code>NXDOMAIN</code></td></tr><tr><td>超时建议</td><td>3 s</td></tr><tr><td>QPS 限制</td><td>≤ 200</td></tr></tbody></table><hr><h2 id="3-架构图"><a href="#3-架构图" class="headerlink" title="3. 架构图"></a>3. 架构图</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌────────────┐      ┌────────────────┐      ┌──────────────┐<br>│   App      │─────▶│  DnsHttpClient │─────▶│   目标站点   │<br>│   (Dio)    │      │   Adapter      │      │ (IP直连+SNI) │<br>└────────────┘      └────────────────┘      └──────────────┘<br>          │                 │<br>          │                 ▼<br>          │        ┌────────────────┐<br>          └─────── │  阿里云HTTPDNS │<br>                   │  (HTTP API)    │<br>                   └────────────────┘<br></code></pre></td></tr></table></figure><hr><h2 id="4-核心代码（纯-Dart）"><a href="#4-核心代码（纯-Dart）" class="headerlink" title="4. 核心代码（纯 Dart）"></a>4. 核心代码（纯 Dart）</h2><h3 id="4-1-阿里云-HTTPDNS-解析器"><a href="#4-1-阿里云-HTTPDNS-解析器" class="headerlink" title="4.1 阿里云 HTTPDNS 解析器"></a>4.1 阿里云 HTTPDNS 解析器</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">阿里云 HTTPDNS（HTTP API 版）</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliHttpDns</span> </span>&#123;<br>  <span class="hljs-comment">// 启动IP列表</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; _startDnsIps = [<span class="hljs-string">&#x27;203.107.1.1&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.33&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.34&#x27;</span>,<span class="hljs-string">&#x27;203.107.1.35&#x27;</span>]; <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> _accountId = <span class="hljs-string">&#x27;xxxxxx&#x27;</span>; <span class="hljs-comment">// 账号ID</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Dio _dio = Dio()<br><br>  <span class="hljs-comment">/// <span class="language-markdown">应用内嵌入多个启动 IP 或域名，确保始终与HTTPDNS服务保持连通性</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">请求失败时，自动切换使用下一个启动 IP</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在下列描述的场景中更新并保存服务IP列表</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在App冷启动时进行更新</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议在切换网络环境时进行更新</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">建议每8小时至少更新一次</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">当服务IP列表经过重试发现都无法解析时，立即更新</span></span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; fetchParseServerAddddress(<span class="hljs-built_in">String</span> startDnsIp) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">// 具体代码待实现</span><br>    <span class="hljs-keyword">return</span> dnsServer;<br>  &#125;<br>  <br>  <span class="hljs-comment">/// <span class="language-markdown">解析域名 -&gt; IP，失败返回原域名降级</span></span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; domainNameResolution(<span class="hljs-built_in">String</span> host) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">final</span> res = <span class="hljs-keyword">await</span> _dio.<span class="hljs-keyword">get</span>&lt;<span class="hljs-built_in">String</span>&gt;(<br>        <span class="hljs-string">&#x27;<span class="hljs-subst">$dnsServer</span>/<span class="hljs-subst">$_accountId</span>&#x27;</span>,<br>        queryParameters: &#123;<span class="hljs-string">&#x27;host&#x27;</span>: host&#125;,<br>      );<br>      <span class="hljs-keyword">final</span> ip = (res.data ?? <span class="hljs-string">&#x27;&#x27;</span>).trim();<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">r&#x27;^\d+\.\d+\.\d+\.\d+$&#x27;</span>).hasMatch(ip) ? ip : host;<br>    &#125; <span class="hljs-keyword">catch</span> (_) &#123;<br>      <span class="hljs-keyword">return</span> host; <span class="hljs-comment">// 降级</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-自定义-HttpClientAdapter"><a href="#4-2-自定义-HttpClientAdapter" class="headerlink" title="4.2 自定义 HttpClientAdapter"></a>4.2 自定义 <code>HttpClientAdapter</code></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:io&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/io.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DnsHttpClientAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpClientAdapter</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> HttpClientAdapter _adapter = IOHttpClientAdapter();<br><br>  <span class="hljs-meta">@override</span><br>  Future&lt;ResponseBody&gt; fetch(<br>    RequestOptions options,<br>    Stream&lt;Uint8List&gt;? requestStream,<br>    Future? cancelFuture,<br>  ) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> host = options.uri.host;<br><br>    <span class="hljs-comment">// 已是 IP 直接转发</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">r&#x27;^\d+\.\d+\.\d+\.\d+$&#x27;</span>).hasMatch(host)) &#123;<br>      <span class="hljs-keyword">return</span> _adapter.fetch(options, requestStream, cancelFuture);<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 解析</span><br>    <span class="hljs-keyword">final</span> ip = <span class="hljs-keyword">await</span> AliHttpDns.resolve(host);<br><br>    <span class="hljs-comment">// 2. 替换 URI</span><br>    <span class="hljs-keyword">final</span> uri = options.uri.replace(host: ip);<br>    options.uri = uri;<br><br>    <span class="hljs-comment">// 3. 设置 Host 头</span><br>    options.headers[<span class="hljs-string">&#x27;Host&#x27;</span>] = host;<br><br>    <span class="hljs-comment">// 4. HTTPS SNI</span><br>    <span class="hljs-keyword">if</span> (uri.isScheme(<span class="hljs-string">&#x27;https&#x27;</span>)) &#123;<br>      (_adapter <span class="hljs-keyword">as</span> IOHttpClientAdapter).onHttpClientCreate = (client) &#123;<br>        client.connectionFactory = (_, __, ___) =&gt;<br>            SecureSocket.startConnect(ip, uri.port, serverName: host);<br>        <span class="hljs-keyword">return</span> client;<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> _adapter.fetch(options, requestStream, cancelFuture);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> close(&#123;<span class="hljs-built_in">bool</span> force = <span class="hljs-keyword">false</span>&#125;) =&gt; _adapter.close(force: force);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-快速接入"><a href="#5-快速接入" class="headerlink" title="5. 快速接入"></a>5. 快速接入</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> dio = Dio()<br>    ..httpClientAdapter = DnsHttpClientAdapter();<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">final</span> res = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://www.aliyun.com&#x27;</span>);<br>    <span class="hljs-built_in">print</span>(res.data);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Request error: <span class="hljs-subst">$e</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-缓存与降级"><a href="#6-缓存与降级" class="headerlink" title="6. 缓存与降级"></a>6. 缓存与降级</h2><p><a href="https://help.aliyun.com/document_detail/2868007.html?spm=a2c4g.11186623.help-menu-434086.d_3_2_5.7b7d127fbAGSkT">参考官方最佳实践</a></p><h2 id="7-平台差异注意点"><a href="#7-平台差异注意点" class="headerlink" title="7. 平台差异注意点"></a>7. 平台差异注意点</h2><table><thead><tr><th>平台</th><th>注意</th></tr></thead><tbody><tr><td><strong>Android 9+</strong></td><td>默认禁止明文 HTTP，需在 <code>network_security_config.xml</code> 允许 <code>203.107.1.33</code>，或改用 HTTPS 解析节点</td></tr><tr><td><strong>iOS</strong></td><td>ATS 同样限制，建议 HTTPS 节点</td></tr><tr><td><strong>Windows</strong></td><td>无额外限制</td></tr></tbody></table><hr><h2 id="8-性能与安全"><a href="#8-性能与安全" class="headerlink" title="8. 性能与安全"></a>8. 性能与安全</h2><ul><li><strong>并发</strong>：单节点 200 QPS 足够日常 App，如流量大可用多节点 + 本地缓存。  </li><li><strong>HTTPS</strong>：通过 <code>serverName</code> 保留原域名，证书校验正常。  </li><li><strong>安全</strong>：解析节点走 HTTPS 可避免中间人篡改解析结果。</li></ul><hr><h2 id="9-常见问题-FAQ"><a href="#9-常见问题-FAQ" class="headerlink" title="9. 常见问题 FAQ"></a>9. 常见问题 FAQ</h2><table><thead><tr><th>现象</th><th>原因</th><th>解决</th></tr></thead><tbody><tr><td>证书验证失败</td><td>未设置 <code>serverName</code></td><td>示例代码已处理</td></tr><tr><td>连接超时</td><td>本地网络禁止 <code>203.107.1.33</code></td><td>换 HTTPS 节点或配置代理</td></tr><tr><td>返回空字符串</td><td>域名未在阿里云备案</td><td>控制台添加域名</td></tr></tbody></table><hr><h2 id="10-相关文档"><a href="#10-相关文档" class="headerlink" title="10. 相关文档"></a>10. 相关文档</h2><table><thead><tr><th>类别</th><th>地址</th><th>说明</th></tr></thead><tbody><tr><td><strong>HTTP API 接入文档</strong></td><td><a href="https://help.aliyun.com/document_detail/435282.html">https://help.aliyun.com/document_detail/435282.html</a></td><td>直接使用 HTTP&#x2F;HTTPS 接口解析域名（本文方案核心）</td></tr><tr><td><strong>Android SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/150879.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/150879.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 Android SDK 接入指南</td></tr><tr><td><strong>iOS SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/150881.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/150881.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 iOS SDK 接入指南</td></tr><tr><td><strong>鸿蒙 SDK</strong></td><td><a href="https://help.aliyun.com/document_detail/2867709.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa">https://help.aliyun.com/document_detail/2867709.html?spm=a2c4g.11186623.0.0.10ff57891A2HJa</a></td><td>官方 HarmonyOS SDK 快速集成</td></tr><tr><td><strong>Flutter接入移动解析HTTPDNS Android&#x2F;iOS SDK实践方案</strong></td><td><a href="https://help.aliyun.com/zh/dns/httpdns-practice-solution-of-connecting-flutter-to-alibaba-cloud-public-dns-android-ios-sdk">https://help.aliyun.com/zh/dns/httpdns-practice-solution-of-connecting-flutter-to-alibaba-cloud-public-dns-android-ios-sdk</a></td><td>官方另外一份Flutter相关文档（供对比参考）</td></tr><tr><td><strong>Flutter 中自定义DNS解析的实现</strong></td><td><a href="https://blog.csdn.net/zdc9023/article/details/140804093">https://blog.csdn.net/zdc9023/article/details/140804093</a></td><td>CSDN上的一篇相关实现</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从架构到源码：一文了解Flutter渲染机制（转载）</title>
    <link href="/2025/08/15/%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%B0%E6%BA%90%E7%A0%81%EF%BC%9A%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <url>/2025/08/15/%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%88%B0%E6%BA%90%E7%A0%81%EF%BC%9A%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="从架构到源码：一文了解Flutter渲染机制（转载）"><a href="#从架构到源码：一文了解Flutter渲染机制（转载）" class="headerlink" title="从架构到源码：一文了解Flutter渲染机制（转载）"></a>从架构到源码：一文了解Flutter渲染机制（转载）</h1><blockquote><p>**简介：**Flutter从本质上来讲还是一个UI框架，它解决的是一套代码在多端渲染的问题。在渲染管线的设计上更加精简，加上自建渲染引擎，相比ReactNative、Weex以及WebView等方案，具有更好的性能体验。本文将从架构和源码的角度详细分析Flutter渲染机制的设计与实现。较长，同学们可收藏后再看。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-359b40ad8399a1203c5fe639b361e47b_1440w.png" alt="image.png"></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>跨平台技术由于其一码多端的生产力提升而表现出巨大的生命力，从早期的Hybrid App到ReactNative&#x2F;Weex、小程序&#x2F;快应用，再到现在的Flutter，跨平台技术一直在解决效率问题的基础上最大化的解决性能和体验问题。这也引出了任何跨平台技术都会面临的核心问题：</p><ul><li>效率：解决在多应用、多平台、多容器上开发效率的问题，一码多端，业务快跑。</li><li>性能：解决的是业务的性能和体验问题。</li></ul><p>效率作为跨平台技术的基本功能，大家都能做到。问题是谁能把性能和体验做得更好，在渲染技术这块一共有三种方案：</p><ul><li>WebView渲染：依赖WebView进行渲染，在功能和性能上有妥协，例如PhoneGap、Cordova、小程序（有的小程序底层也采用了ReactNative等渲染方案）等。</li><li>原生渲染：上层拥抱W3C，通过中间层把前端框架翻译为原生控件，例如ReactNative+React、Weex+Vue的组合，这种方案多了一层转译层，性能上有损耗。随着原生系统的升级，在兼容性上也会有问题。</li><li>自建渲染：自建渲染框架，底层使用<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=Skia&zhida_source=entity">Skia</a>等图形库进行渲染，例如Flutter、Unity。</li></ul><p>Flutter由于其自建渲染引擎，贴近原生的实现方式，获得了优秀的渲染性能。</p><p>Flutter拥有自己的开发工具，开发语言、虚拟机，编译机制，线程模型和渲染管线，和Android相比，它也可以看做一个小型的OS了。</p><p>第一次接触Flutter，可以看看Flutter的创始人Eric之前的访谈《What is Flutter？》，Eric之前致力于Chromium渲染管线的设计与开发，因此Flutter的渲染与Chromium有一定的相似之处，后面我们会做下类比。</p><p>后面我们会从架构和源码的角度分析Flutter渲染机制的设计与实现，在此之前也可以先看看Flutter官方对于渲染机制的分享《How Flutter renders Widgets》。视频+图文的方式会更加直观，可以有一个大体的理解。</p><h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p><img src="https://pic2.zhimg.com/v2-2ea9f2735444827f8de655d722c1f7bf_1440w.png" alt="image.png"></p><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>从结构上看，Flutter渲染由UI Thread与GPU Thread相互配合完成。</p><p>1）UI Thread</p><p>对应图中1-5，执行<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=Dart+VM&zhida_source=entity">Dart VM</a>中的Dart代码（包含应用程序和Flutter框架代码），主要负责Widget Tree、Element Tree、<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=RenderObject+Tree&zhida_source=entity">RenderObject Tree</a>的构建，布局、以及绘制生成绘制指令，生成Layer Tree（保存绘制指令）等工作。</p><p>2）GPU Thread</p><p>对应图中6-7，执行Flutter引擎中图形相关代码（Skia），这个线程通过与GPU通信，获取Layer Tree并执行栅格化以及合成上屏等操作，将Layer Tree显示在屏幕上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">注：图层树（Layer Tree）是Flutter组织绘制指令的方式，类似于Android Rendering里的View DisplayList，都是组织绘制指令的一种方式。<br></code></pre></td></tr></table></figure><p>UI Thread与GPU Thread属于生产者和消费者的角色。</p><h4 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h4><p>我们知道Android上的渲染都是在VSync信号驱动下进行的，Flutter在Android上的渲染也不例外，它会向Android系统注册并等待VSync信号，等到VSync信号到来以后，调用沿着C++ Engine-&gt;Java Engine，到达Dart Framework，开始执行Dart代码，经历Layout、Paint等过程，生成一棵Layer Tree，将绘制指令保存在Layer中，接着进行栅格化和合成上屏。</p><p>具体说来：</p><p><img src="https://pic2.zhimg.com/v2-f96505692019ea265a2a4e29e644f48f_1440w.png" alt="image.png"></p><p>1）向Android系统注册并等待VSync信号</p><p>Flutter引擎启动时，会向Android系统的Choreographer（管理VSync信号的类）注册并接收VSync信号的回调。</p><p>2）接收到VSync信号，通过C++ Engine向Dart Framework发起渲染调用</p><p>当VSync信号产生以后，Flutter注册的回调被调用，VsyncWaiter::fireCallback() 方法被调用，接着会执行 Animator::BeiginFrame()，最终调用到 Window::BeginFrame() 方法，WIndow实例是连接底层Engine和Dart Framework的重要桥梁，基本上与平台相关的操作都会通过Window实例来连接，例如input事件、渲染、无障碍等。</p><p>3）Dart Framework开始在UI线程执行渲染逻辑，生成Layer Tree，并将栅格化任务post到GPU线程执行</p><p>Window::BeiginFrame() 接着调用，执行到 RenderBinding::drawFrame() 方法，这个方法会去驱动UI界面上的dirty节点（需要重绘的节点）进行重新布局和绘制，如果渲染过程中遇到图片，会先放到Worker Thead去加载和解码，然后再放到IO Thread生成图片纹理，由于IO Thread和GPI Thread共享EGL Context，因此IO Thread生成的图片纹理可以被GPU Thread直接访问。</p><p>4）GPU线程接收到Layer Tree，进行栅格化以及合成上屏的工作</p><p>Dart Framework绘制完成以后会生成绘制指令保存在Layer Tree中，通过 Animator::RenderFrame() 把Layer Tree提交给GPU Thread，GPU Thread接着执行栅格化和上屏显示。之后通过 Animator::RequestFrame() 请求接收系统的下一次VSync信号，如此循环往复，驱动UI界面不断更新。</p><p>逐个调用流程比较长，但是核心点没多少，不用纠结调用链，抓住关键实现即可，我们把里面涉及到的一些主要类用颜色分了个类，对着这个类图，基本可以摸清Flutter的脉络。</p><p><img src="https://pic2.zhimg.com/v2-7416f821280caddbf9effbb3c8db5f87_1440w.png" alt="image.png"></p><p>绿色：Widget 黄色：Element 红色：RenderObject</p><p>以上便是Flutter渲染的整体流程，会有多个线程配合，多个模块参与，抛开冗长的调用链，我们针对每一步来具体分析。我们在分析结构时把Flutter的渲染流程分为了7大步，Flutter的timeline也可以清晰地看到这些流程，如下所示：</p><p><img src="https://pic1.zhimg.com/v2-6d075fe2dbbdcad99ff6438477ca90da_1440w.png" alt="image.png"></p><p><strong>UI Thread</strong></p><p>1）Animate</p><p>由 handleBeiginFrame() 方法的transientCallbacks触发，如果没有动画，则该callback为空；如果有动画，则会回调 Ticker.tick() 触发动画Widget更新下一帧的值。</p><p>2）Build</p><p>由 BuildOwner.buildScope() 触发，主要用来构建或者更新三棵树，Widget Tree、Element Tree和RenderObject Tree。</p><p>3）Layout</p><p>由 PipelineOwner.flushLayout() 触发，它会调用 RenderView.performLayout()，遍历整棵Render Tree，调用每个节点的 layout()，根据build过程记录的信息，更新dirty区域RenderObject的排版数据，使得每个RenderObject最终都能有正确的大小（size）和位置（position，保存在parentData中）。</p><p>4）Compositing Bits</p><p>由 PipelineOwner.flushCompositingBits() 触发，更新具有dirty合成位置的渲染对象，此阶段每个渲染对象都会了解其子项是否需要合成，在绘制阶段使用此信息选择如何实现裁剪等视觉效果。</p><p>5）Paint</p><p>由 PipeOwner.flushPaint() 触发，它会调用 RenderView.paint()。最终触发各个节点的 paint()，最终生成一棵Layer Tree，并把绘制指令保存在Layer中。</p><p>6）Submit（Compositing）</p><p>由 renderView.compositeFrame() 方法触发，这个地方官方的说法叫Compositing，不过我觉得叫Compositing有歧义，因为它并不是在合成，而是把Layer Tree提交给GPU Thread，因而我觉得叫Submit更合适。</p><p><strong>GPU Thread</strong></p><p>7）Compositing</p><p>由 Render.compositeFrame() 触发，它通过Layer Tree构建一个Scene，传给Window进行最终的光栅化。</p><p>GPU Thread通过Skia向GPU绘制一帧数据，GPU将帧信息保存在FrameBuffer里，然后根据VSync信号周期性的从FrameBuffer取出帧数据交给显示器，从而显示出最终的界面。</p><h3 id="Rendering-Pipeline"><a href="#Rendering-Pipeline" class="headerlink" title="Rendering Pipeline"></a>Rendering Pipeline</h3><p>Flutter引擎启动时，向Android系统的Choreographer注册并接收VSync信号，GPU硬件产生VSync信号以后，系统便会触发回调，并驱动UI线程进行渲染工作。</p><h4 id="1-Animate"><a href="#1-Animate" class="headerlink" title="1 Animate"></a>1 Animate</h4><p>触发方法：由 handleBeiginFrame() 方法的transientCallbacks触发</p><p>Animate在 handleBeiginFrame() 方法里由transientCallbacks触发，如果没有动画，则该callback为空；如果有动画，则会回调 Ticker._tick() 触发动画Widget更新下一帧的值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">void handleBeginFrame(Duration rawTimeStamp) &#123;<br>    ...<br>    try &#123;<br>      // TRANSIENT FRAME CALLBACKS<br>      Timeline.startSync(&#x27;Animate&#x27;, arguments: timelineWhitelistArguments);<br>      _schedulerPhase = SchedulerPhase.transientCallbacks;<br>      final Map&lt;int, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;<br>      _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;&#123;&#125;;<br>      callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) &#123;<br>        if (!_removedIds.contains(id))<br>          _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);<br>      &#125;);<br>      ...<br>    &#125; finally &#123;<br>      ...<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>handleBeiginFrame() 处理完成以后，接着调用 handleDrawFrame()，handleDrawFrame() 会触发以下回调：</p><ul><li>postFrameCallbacks用来通知监听者绘制已经完成。</li><li>pesistentCallbacks用来触发渲染。</li></ul><p>这两个回调都是SchedulerBinding内部的回调队列，如下所示：</p><ul><li>_transientCallbacks：用于存放一些临时回调，目前是在 Ticker.scheduleTick() 中注册，用来驱动动画。</li><li>_persistentCallbacks：用来存放一些持久回调，不能在此回调中再请求新的绘制帧，持久回调一经注册就不嫩嫩移除， RenderBinding.initInstaces().addPersitentFrameCallback() 添加了一个持久回调，用来触发 drawFrame()。</li><li>_postFrameCallbacks：在Frame结束时会被调用一次，调用后会被移除，它主要是用来通知监听者这个Frame已经完成。</li></ul><p>接着会调用 WidgetBinder.drawFrame() 方法，它会先调用会先调用 BuildOwner.buildScope() 触发树的更新，然后才进行绘制。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">@override<br>void drawFrame() &#123;<br>  ...<br>  try &#123;<br>    if (renderViewElement != null)<br>      buildOwner.buildScope(renderViewElement);<br>    super.drawFrame();<br>    buildOwner.finalizeTree();<br>  &#125; finally &#123;<br>    assert(() &#123;<br>      debugBuildingDirtyElements = false;<br>      return true;<br>    &#125;());<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用 RenderingBinding.drawFrame() 触发layout、paingt等流程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">void drawFrame() &#123;<br>  assert(renderView != null);<br>  pipelineOwner.flushLayout();<br>  pipelineOwner.flushCompositingBits();<br>  pipelineOwner.flushPaint();<br>  if (sendFramesToEngine) &#123;<br>    renderView.compositeFrame(); // this sends the bits to the GPU<br>    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.<br>    _firstFrameSent = true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上便是核心流程代码，我们接着来Build的实现。</p><h4 id="2-Build"><a href="#2-Build" class="headerlink" title="2 Build"></a>2 Build</h4><p>触发方法：由 BuildOwner.buildScope() 触发。</p><p>我们上面说到，handleDrawFrame() 会触发树的更新，事实上 BuildOwner.buildScope() 会有两种调用时机：</p><ul><li>树构建（应用启动时）：我们上面提到的 runApp() 方法调用的 scheduleAttachRootWidget() 方法，它会构建Widgets Tree、Element Tree与RenderObject Tree三棵树。</li><li>树更新（帧绘制与更新时）：这里不会重新构建三棵树，而是只会更新dirty区域的Element。</li></ul><p>也即是说树的构建和更新都是由 BuildOwner.buildScope() 方法来完成的。它们的差别在于树构建的时候传入了一个 element.mount(null, null) 回调。在 buildScope() 过程中会触发这个回调。</p><p>这个回调会构建三棵树，为什么会有三棵树呢，因为Widget只是对UI元素的一个抽象描述，我们需要先将其inflate成Element，然后生成对应的RenderObject来驱动渲染，如下所示：</p><ul><li>Widget Tree：为Element描述需要的配置，调用createElement方法创建Element，决定Element是否需要更新。Flutter通过查分算法比对Widget树前后的变化，来决定Element的State是否改变。</li><li>Element Tree：表示Widget Tree特定位置的一个实例，调用createRenderObject创建RenderObject，同时持有Widget和RenderObject，负责管理Widget的配置和RenderObjec的渲染。Element的状态由Flutter维护，开发人员只需要维护Widget即可。</li><li>RenderObject Tree：RenderObject绘制，测量和绘制节点，布局子节点，处理输入事件。</li></ul><h4 id="3-Layout"><a href="#3-Layout" class="headerlink" title="3 Layout"></a>3 Layout</h4><p>触发方法：由 PipelineOwner.flushLayout() 触发。</p><ul><li>相关文档：Understanding constraints</li><li>相关源码：PipelineOwner.flushLayout()</li></ul><p>Layout是基于单向数据流来实现的，父节点向子节点传递约束（Constraints），子节点向父节点传递大小（Size，保存在父节点的parentData变量中）。先深度遍历RenderObject Tree，然后再递归遍历约束。单向数据流让布局流程变得更简单，性能也更好。</p><p><img src="https://picx.zhimg.com/v2-702e4335e17edc01448263c0d9ac3f1d_1440w.png" alt="image.png"></p><p>对于RenderObject而言，它只是提供了一套基础的布局协议，没有定义子节点模型、坐标系统和具体的布局协议。它的子类RenderBox则提供了一套笛卡尔坐标体系（和Android&amp;iOS一样），大部分RenderObject类都是直接继承RenderBox来实现的。RenderBox有几个不同的子类实现，它们各自对应了不同的布局算法。</p><ul><li>RenderFlex：弹性布局，这是一种很常见的布局方式，它对应的是Widget组件Flex、Row和Column。关于这一块的布局算法代码注释里有描述，也可以直接看这篇文章的解释。</li><li>RenderStack：栈布局。</li></ul><p>我们再来聊聊Layout流程中涉及的两个概念边界约束（Constraints）和重新布局边界（RelayoutBoundary）。</p><blockquote><p>边界约束（Constraints）：边界约束是父节点用来限制子节点的大小的一种方式，例如BoxConstraints、SliverConstraints等。</p></blockquote><p>RenderBox提供一套BoxConstraints，如图所示，它会提供以下限制：</p><ul><li>minWidth</li><li>maxWidth</li><li>minHeight</li><li>maxHeight</li></ul><p>利用这种简单的盒模型约束，我们可以非常灵活的实现很多常见的布局，例如完全和父节点一样的大小，垂直布局（宽度和父节点一样大）、水平布局（高度和父容器一样大）。</p><p>通过Constraints和子节点自己配置的大小信息，就可以最终算出子节点的大小，接下来就需要计算子节点的位置。子节点的位置是由父节点来决定的。</p><blockquote><p>重新布局边界（RelayoutBoundary）：为一个子节点设置重新布局边界，这样当它的大小发生变化时，不会导致父节点重新布局，这是个标志位，在标记dirty的markNeedsLayout()方法中会检查这个标记位来决定是否重新进行布局。</p></blockquote><p>重新布局边界这种机制提升了布局排版的性能。</p><p>通过Layout，我们了解了所有节点的位置和大小，接下来就会去绘制它们。</p><h4 id="4-Compositing-Bits"><a href="#4-Compositing-Bits" class="headerlink" title="4 Compositing Bits"></a>4 Compositing Bits</h4><p>触发方法：由 PipelineOwner.flushCompositingBits() 触发。</p><p>在Layout之后，在Paint之前会先执行Compositing Bits，它会检查RenderObject是否需要重绘，然后更新RenderObject Tree各个节点的needCompositing标志。如果为true，则需要重绘。</p><h4 id="5-Paint"><a href="#5-Paint" class="headerlink" title="5 Paint"></a>5 Paint</h4><p>触发方法：由 PipeOwner.flushPaint() 触发。</p><p>相关源码：</p><ul><li>Dart层调用入口：painting.dart</li><li>C++层实现：<a href="https://link.zhihu.com/?target=http://canvas.cc">http://canvas.cc</a></li></ul><p>我们知道现代的UI系统都会进行界面的图层划分，这样可以进行图层复用，减少绘制量，提升绘制性能，因此Paint（绘制）的核心问题还是解决绘制命令应该放到哪个图层的问题。</p><p><img src="https://pica.zhimg.com/v2-07f93a0590850e6357057cd9030263c2_1440w.png" alt="image.png"></p><p>Paint的过程也是单向数据流，先向下深度遍历RenderObject Tree，再递归遍历子节点，遍历的过程中会决定每个子节点的绘制命令应该放在那一层，最终生成Layer Tree。</p><p>和Layout一样，为了提到绘制性能，绘制阶段也引入了重新绘制边界。</p><blockquote><p>重新绘制边界（<a href="https://zhida.zhihu.com/search?content_id=128971520&content_type=Article&match_order=1&q=RepaintBoundary&zhida_source=entity">RepaintBoundary</a>）：为一个子节点设置重新绘制边界，这样当它需要重新绘制时，不会导致父节点重新绘制，这是个标志位，在标记dirty的markNeedsPaint()方法中会检查这个标记位来决定是否重新进行重绘。</p></blockquote><p>事实上这种重绘边界的机制相对于把图层分层这个功能开放给了开发者，开发者可以自己决定自己的页面那一块在重绘时不参与重绘（例如滚动容器），以提升整体页面的性能。重新绘制边界会改变最终的图层树（Layer Tree）结构。</p><p>当然这些重绘边界并不都需要我们手动放置，大部分Widget组件会自动放置重绘边界（自动分层）。</p><p>设置了RepaintBoundary的就会额外生成一个图层，其所有的子节点都会被绘制在这个新的图层上，Flutter中使用图层来描述一个层次上（一个绘制指令缓冲区）的所有RenderObject，根节点的RenderView会创建Root Layer，并且包含若干个子Layer，每个Layer又包含多个RenderObject，这些Layer便形成了一个Layer Tree。每个RenderObject在绘制时，会产生相关的绘制指令和绘制参数，并保存在对应的Layer上。</p><p>相关Layer都继承Layer类，如下所示：</p><ul><li>ClipRectLayer：矩形裁剪层，可以指定裁剪和矩形行为参数。共有4种裁剪行为，none、hardEdge、antiAlias、antiAliashWithSaveLayer。</li><li>ClipRRectLayer：圆角矩形裁剪层，行为同上。</li><li>ClipPathLayer：路径裁剪层，可以指定路径和行为裁剪参数，行为同上。</li><li>OpacityLayer：透明层，可以指定透明度和偏移（画布坐标系原点到调用者坐标系原点的偏移）参数。</li><li>ShaderMaskLayer：着色层，可以指定着色器矩阵和混合模式参数。</li><li>ColorFilterLayer：颜色过滤层，可以指定颜色和混合模式参数。</li><li>TransformLayer：变换图层，可以指定变换矩阵参数。</li><li>BackdropFilterLayer：背景过滤层，可以指定背景图参数。</li><li>PhysicalShapeLayer：物理性状层，可以指定颜色等八个参数。</li></ul><p>具体可以参考文章上方的Flutter类图。</p><p>聊完了绘制的基本概念，我们再来看看绘制的具体流程，上面提到渲染第一帧的时候，会从根节点RenderView开始，逐个遍历所有子节点进行操作。如下所示：</p><p>1）创建Canvas对象</p><p>Canvas对象通过PaintCotext获取，它内部会创建一个PictureLayer，并通过ui.PictureRecorder调用到C++层创建一个Skia的SkPictureRecorder的实例，并通过SkPictureRecorder创建SkCanvas，而后将SkCanvas返回给Dart Framework使用。SkPictureRecorder可以用来记录生成的绘制命令。</p><p>2）通过Canvas执行绘制</p><p>绘制命令会被SkPictureRecorder记录下来。</p><p>3）通过Canvas结束绘制，准备进行栅格化</p><p>绘制结束后，会调用 Canvas.stopRecordingIfNeeded() 方法，它会接着去调用C++层的SkPictureRecorder::endRecording()方法生成一个Picture对象并保存在PictureLayer中，Picture对象包含了所有的绘制指令。所有的Layer绘制完成，形成Layer Tree。</p><p>绘制完成以后，接着就可以向GPU Thread提交Layer Tree了。</p><h4 id="6-Submit（Compositing）"><a href="#6-Submit（Compositing）" class="headerlink" title="6 Submit（Compositing）"></a>6 Submit（Compositing）</h4><p>触发方法：由 renderView.compositeFrame() 方法触发。</p><ul><li>Dart层调用入口：compositing.dart widow.dart</li><li>C++层实现：<a href="https://link.zhihu.com/?target=http://scene.cc">http://scene.cc</a><a href="https://link.zhihu.com/?target=http://scene_builder.cc">http://scene_builder.cc</a></li></ul><blockquote><p>注：这个地方官方的说法叫Compositing，不过我觉得叫Compositing有歧义，因为它并不是在合成，而是把Layer Tree提交给GPU Thread，因而我觉得叫Submit更合适。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">void compositeFrame() &#123;<br>    Timeline.startSync(&#x27;Compositing&#x27;, arguments: timelineArgumentsIndicatingLandmarkEvent);<br>    try &#123;<br>      final ui.SceneBuilder builder = ui.SceneBuilder();<br>      final ui.Scene scene = layer.buildScene(builder);<br>      if (automaticSystemUiAdjustment)<br>        _updateSystemChrome();<br>      _window.render(scene);<br>      scene.dispose();<br>      assert(() &#123;<br>        if (debugRepaintRainbowEnabled || debugRepaintTextRainbowEnabled)<br>          debugCurrentRepaintColor = debugCurrentRepaintColor.withHue((debugCurrentRepaintColor.hue + 2.0) % 360.0);<br>        return true;<br>      &#125;());<br>    &#125; finally &#123;<br>      Timeline.finishSync();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>创建SceneBuilder对象，并通过 SceneBuilder.addPicture() 将上文中生成的Picture添加到SceneBuilder对象对象中。</li><li>通过 SceneBuilder.build() 方法生成Scene对象，接着会通过window.render(scene)将包含绘制指令的Layer Tree提交给CPU线程进行光栅化和合成。</li></ul><p>在这个过程中Dart Framework层的Layer会被转换为C++层使用的flow::layer，Flow模块是一个基于Skia的简单合成器，运行在GPU线程，并向Skia上传指令信息。Flutter Engine使用flow缓存Paint阶段生成的绘制指令和像素信息。我们在Paint阶段的Layer，它们都与Flow模块里的Layer一一对应。</p><p><img src="https://pic1.zhimg.com/v2-682316d05b941b90d89cffe1749ad436_1440w.png" alt="image.png"></p><h3 id="Graphics-Pipeline"><a href="#Graphics-Pipeline" class="headerlink" title="Graphics Pipeline"></a>Graphics Pipeline</h3><h4 id="7-Raster-Compositing"><a href="#7-Raster-Compositing" class="headerlink" title="7 Raster&amp;Compositing"></a>7 Raster&amp;Compositing</h4><p>有了包含渲染指令的Layer Tree以后就可以进行光栅化和合成了。</p><blockquote><p>光栅化是把绘制指令转换成对应的像素数据，合成是把各图层栅格化后的数据进行相关的叠加和特性处理。这个流程称为Graphics Pipeline。</p></blockquote><p>相关代码：<a href="https://link.zhihu.com/?target=http://rasterizer.cc">http://rasterizer.cc</a></p><p>Flutter采用的是同步光栅化。什么是同步光栅化？</p><p>同步光栅化：</p><blockquote><p>光栅化和合成在一个线程，或者通过线程同步等方式来保证光栅化和合成的的顺序。</p></blockquote><p>直接光栅化：直接执行可见图层的DisplayList中可见区域的绘制指令进行光栅化，在目标Surface的像素缓冲区上生成像素的颜色值。<br>间接光栅化：为指定图层分配额外的像素缓冲区（例如Android提供View.setLayerType允许应用为指定View提供像素缓冲区，Flutter提供了Relayout Boundary机制来为特定图层分配额外缓冲区），该图层光栅化的过程中会先写入自身的像素缓冲区，渲染引擎再将这些图层的像素缓冲区通过合成输出到目标Surface的像素缓冲区。</p><p>异步分块光栅化：</p><blockquote><p>图层会按照一定的规则粉尘同样大小的图块，光栅化以图块为单位进行，每个光栅化任务执行图块区域内的指令，将执行结果写入分块的像素缓冲区，光栅化和合成不在一个线程内执行，并且不是同步的。如果合成过程中，某个分块没有完成光栅化，那么它会保留空白或者绘制一个棋盘格图形。</p></blockquote><p>Android和Flutter采用同步光栅化策略，以直接光栅化为主，光栅化和合成同步执行，在合成的过程中完成光栅化。而Chromium采用异步分块光栅化测量，图层会进行分块，光栅化和合成异步执行。</p><p>从文章上方的序列图可以看到，光栅化的入口是 Rasterizer::DoDraw() 方法。它会接着调用 ScopedFrame::Raster() 方法，这个方法就是光栅化的核心实现，它主要完成以下工作：</p><ul><li>LayerTree::Preroll()：处理绘制前的一些准备工作。</li><li>LayerTree::Paint()：嵌套调用不通Layer的绘制方法。</li><li>SkCanvas::Flush()：将数据flush给GPU。</li><li>AndroidContextGL::SwapBuffers()：交换帧缓存给显示器显示。</li></ul><p>到这里我们Flutter整体的渲染实现我们就分析完了。</p><h3 id="Android、Chromium与Flutter"><a href="#Android、Chromium与Flutter" class="headerlink" title="Android、Chromium与Flutter"></a>Android、Chromium与Flutter</h3><p>Android、Chromium、Flutter都作为Google家的明星级项目，它们在渲染机制的设计上既有相似又有不同，借着这个机会我们对它们做个比较。</p><p>现代渲染流水线的基本设计：</p><p><img src="https://pic2.zhimg.com/v2-e8daeb51487d19fdcb37b964e4a7c25b_1440w.png" alt="image.png"></p><p>我们再分别来看看Android、Chromium和Flutter是怎么实现的。</p><p>Android渲染流水线：</p><p><img src="https://picx.zhimg.com/v2-9a33c28c7e3bda157ebf057a8607b3cb_1440w.png" alt="image.png"></p><p>Chromium渲染流水线：</p><p><img src="https://pic4.zhimg.com/v2-39daae787aa59f92d7d10bee00851a9b_1440w.png" alt="image.png"></p><p>Flutter渲染流水线：</p><p><img src="https://pic3.zhimg.com/v2-649010987227d1392f589d601cbc727a_1440w.png" alt="image.png"></p><p>相互比较：</p><p><img src="https://pic3.zhimg.com/v2-cd3655c9b26665ef5aa872d66cadbbae_1440w.png" alt="image.png"></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最后的最后，谈一谈我对跨平台生态的理解。</p><p>跨平台容器生态至少可以分为三个方面：</p><p><img src="https://pic2.zhimg.com/v2-efe0e18902da772089e4e8080bc10429_1440w.png" alt="image.png"></p><h4 id="前端框架生态"><a href="#前端框架生态" class="headerlink" title="前端框架生态"></a>前端框架生态</h4><p>前端框架生态直接面向的是业务，它应该具备两个特点：</p><ul><li>拥抱W3C生态</li><li>相对稳定性</li></ul><p>它应该是拥抱W3C生态的。W3C生态是一个繁荣且充满活力的生态，它会发展的更久更远。试图抛弃W3C生态，自建子集的做法很难走的长远。这从微信小程序、Flutter都推出for web系列就能看出端倪。</p><p>它应该是相对稳定的。不能说我们每换一套容器，前端的业务就需要重新写一遍，例如我们之前做H5容器，后来做小程序容器，因为DSL不通，前端要花大力气将业务重写。虽然小程序是一码多端，但是我认为这并没有解决效率问题，主要存在两个问题：</p><ul><li>前端的学习成本增加，小程序的DSL还算简单，Flutter的Widget体系学习起来就需要花上一点时间，这些对于团队来说都是成本。</li><li>业务代码重写，大量逻辑需要梳理，而且老业务并不一定都适合迁移到新容器上，比如小程序本来就是个很轻量的解决方案，但是我们在上面堆积了很多功能，造成了严重的体验问题。</li></ul><p>在这种情况下，业务很难实现快速奔跑。所以说不管底层容器怎么变，前端的框架一定是相对稳定的。而这种稳定性就有赖于容器统一层。</p><h4 id="容器统一层"><a href="#容器统一层" class="headerlink" title="容器统一层"></a>容器统一层</h4><p>容器统一层是在前端框架和容器层之间的一个层级。它定义了容器提供的基本能力，这些能力就像协议一样，是相对稳定的。</p><p>协议是非常重要的，就像OpenGL协议一样，有了OpenGL协议，不管底层的渲染方案如何实现，上层的调用是不用变的。对于我们的业务也是一样，围绕着容器统一层，我们需要沉淀通用的解决方案。</p><ul><li>统一API解决方案</li><li>统一性能解决方案</li><li>统一组件解决方案</li><li>统一配套设施解决方案</li><li>等等</li></ul><p>这些东西不能说每搞一套容器，我们都要大刀阔斧重来一遍，这种做法是有问题的。已经做过的东西，遇到新的技术就推倒重来，只能说明以前定义的方案考虑不周全，没有考虑沉淀统一和扩展的情况。</p><p>如果我们自顾自的一遍遍做着功能重复的技术方案，业务能等着我们吗。</p><h4 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h4><p>容器层的迭代核心是为了在解决效率问题的基础上最大化的解决性能和体验问题。</p><p>早期的ReactNative模式解决了效率了问题，但是多了一个通信层（ReactNative是依靠将虚拟DOM的信息传递给原生，然后原生根据这些布局信息构建对应的原生控件树来实现的原生渲染）存在性能问题，而且这种转译的方式需要适配系统版本，带来更多的兼容性问题。</p><p>微信后续又推出了小程序方案，在我看来，小程序方案不像是一个技术方案，它更像是一个商业解决方案，解决了平台大流量规范管理和分发的问题，给业务方提供通用的技术解决方案，当然小程序底层的渲染方案也是多种多样的。</p><p>后起之秀Flutter解决的痛点是性能能力，它自建了一套GUI系统，底层直接调用Skia图形库进行渲染（与Android的机制一样），进而实现了原生渲染。但是它基于开发效率、性能以及自身生态等因素的考虑最终选择了Dart，这种做法无疑是直接抛弃了繁荣的前端生态，就跨平台容器的发展历史来看，在解决效率与性能的基础上，最大化的拥抱W3C生态，可能是未来最好的方向。Flutter目前也推出了Flutter for Web，从它的思路来看，是先打通Android与iOS，再逐步向Web渗透，我们期待它的表现。</p><p>容器技术是动态向前发展的，我们今年搞Flutter，明年可能还会搞其他技术方案。在方案变迁的过程中，我们需要保证业务快速平滑的过度，而不是每次大刀阔斧的再来一遍。</p><p>随着手机性能的提升，WebView的性能也越来越好，Flutter又为解决性能问题提供了新的思路，一个基础设施完善，体验至上，一码多端的跨平台容器生态值得期待。</p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>欢迎加入本地生活终端技术部！</p><p>本地生活终端技术部隶属于阿里本地生活用户技术部，从事客户端技术研发工作，主要负责本地生活饿了么App 和 口碑App 的客户端架构、基础中间件、跨平台技术解决方案，以及账号、首页、全局购物车、收银台、订单列表、红包卡券、直播、短视频等平台化核心业务链路。目前团队规模50+人，我们依托阿里强大的终端技术底盘，以及本地生活的业务土壤，致力于打造最优秀的O2O技术团队。</p><p>招聘本地生活-客户端开发专家&#x2F;高级技术专家-杭州&#x2F;上海&#x2F;北京，欢迎您的加盟！简历发送至 <a href="mailto:&#x77;&#117;&#x73;&#104;&#x69;&#64;&#97;&#x6c;&#105;&#98;&#x61;&#98;&#x61;&#x2d;&#105;&#x6e;&#x63;&#x2e;&#99;&#111;&#109;">wushi@alibaba-inc.com</a></p><blockquote><p>附录</p></blockquote><p>相关平台<br>[1]Flutter pub.dev<br>（<a href="https://link.zhihu.com/?target=https://pub.dev/flutter/packages">https://pub.dev/flutter/packages</a>）<br>相关文档<br>[1]Flutter 官方文档<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/get-started/install/macos">https://flutter.dev/docs/get-started/install/macos</a>）<br>[2]Flutter for Android developers<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/get-started/flutter-for/android-devs">https://flutter.dev/docs/get-started/flutter-for/android-devs</a>）<br>[3]Flutter Widget Doc<br>（<a href="https://link.zhihu.com/?target=https://flutter.dev/docs/reference/widgets">https://flutter.dev/docs/reference/widgets</a>）<br>[4]Flutter API Doc（<a href="https://link.zhihu.com/?target=https://api.flutter.dev/">https://api.flutter.dev/</a>）<br>[5]Dart Doc<br>（<a href="https://link.zhihu.com/?target=https://dart.dev/guides/language">https://dart.dev/guides/language</a>）<br>相关源码<br>[1]Dart Framework<br>（<a href="https://link.zhihu.com/?target=https://github.com/flutter/flutter/tree/master/packages">https://github.com/flutter/flutter/tree/master/packages</a>）<br>[2]Flutter Engine<br>（<a href="https://link.zhihu.com/?target=https://github.com/flutter/engine">https://github.com/flutter/engine</a>）<br>相关资源<br>[1]Flutter Render Pipeline<br>（<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=UUfXWzp0-DU">https://www.youtube.com/watch?v=UUfXWzp0-DU</a>）<br>[2]How Flutter renders Widgets<br>（<a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=996ZgFRENMs">https://www.youtube.com/watch?v=996ZgFRENMs</a>）<br>[3]深入了解Flutter的高性能图形渲染 video<br>（<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av48772383">https://www.bilibili.com/video/av48772383</a>）<br>[4]深入了解Flutter的高性能图形渲染 ppt<br>（<a href="https://link.zhihu.com/?target=https://files.flutter-io.cn/events/gdd2018/Deep_Dive_into_Flutter_Graphics_Performance.pdf">https://files.flutter-io.cn/events/gdd2018/Deep_Dive_into_Flutter_Graphics_Performance.pdf</a>）</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Firebase Flutter项目实践</title>
    <link href="/2025/08/15/Google-Firebase-Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/08/15/Google-Firebase-Flutter%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Google-Firebase-Flutter项目实践"><a href="#Google-Firebase-Flutter项目实践" class="headerlink" title="Google Firebase Flutter项目实践"></a>Google Firebase Flutter项目实践</h1><h2 id="Crashlytics"><a href="#Crashlytics" class="headerlink" title="Crashlytics"></a>Crashlytics</h2><blockquote><p>这是我们的报错统计插件，非常实用的一个插件，可以监测到你在线上的崩溃和错误 ❌ 问题，类似于Bugly功能。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在 Flutter 项目中<a href="https://firebase.google.com/docs/flutter/setup?authuser=0">配置并初始化 Firebase</a>（如果尚未执行此操作）。</p></li><li><p><strong>建议做法</strong>：如需使用“未遇到崩溃问题的用户”、“面包屑导航日志”和“疾速崩溃提醒”等功能，您需要在 Firebase 项目中启用 Google Analytics（分析）。</p><p>Crashlytics 支持的所有 Android 和 Apple 平台（watchOS 除外）都可以利用 Google Analytics（分析）中的这些功能。</p><p>确保您的 Firebase 项目中启用了 Google Analytics（分析）：前往 settings &gt;“项目设置”&gt;“集成”标签页，然后按照 Google Analytics（分析）对应的屏幕上的说明进行操作。</p></li></ol><h2 id="第-1-步：将-Crashlytics-添加到您的-Flutter-项目"><a href="#第-1-步：将-Crashlytics-添加到您的-Flutter-项目" class="headerlink" title="第 1 步：将 Crashlytics 添加到您的 Flutter 项目"></a><strong>第 1 步</strong>：将 Crashlytics 添加到您的 Flutter 项目</h2><ol><li><p>从 Flutter 项目的根目录运行以下命令，安装 Crashlytics Flutter 插件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter pub add firebase_crashlytics<br></code></pre></td></tr></table></figure></li><li><p>从 Flutter 项目的根目录运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutterfire configure<br></code></pre></td></tr></table></figure><p>运行此命令可确保您的 Flutter 应用的 Firebase 配置是最新的，对于 Android，还会向您的应用添加所需的 Crashlytics Gradle 插件。</p></li><li><p>完成后，重新构建您的 Flutter 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter run<br></code></pre></td></tr></table></figure></li></ol><h2 id="第-2-步：配置崩溃处理程序"><a href="#第-2-步：配置崩溃处理程序" class="headerlink" title="第 2 步：配置崩溃处理程序"></a><strong>第 2 步</strong>：配置崩溃处理程序</h2><p>您可以使用 <code>FirebaseCrashlytics.instance.recordFlutterFatalError</code> 替换 <code>FlutterError.onError</code>，自动捕获 Flutter 框架中抛出的所有错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  WidgetsFlutterBinding.ensureInitialized();<br><br>  <span class="hljs-keyword">await</span> Firebase.initializeApp();<br><br>  <span class="hljs-comment">// Pass all uncaught errors from the framework to Crashlytics.</span><br>  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;<br><br>  runApp(MyApp());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您使用区域 (zone)，则对区域的错误处理程序进行插桩 (instrument) 后，系统将捕获 Flutter 框架（例如，在按钮的 <code>onPressed</code> 处理程序中）未捕获的错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  runZonedGuarded&lt;Future&lt;<span class="hljs-keyword">void</span>&gt;&gt;(() <span class="hljs-keyword">async</span> &#123;<br>    WidgetsFlutterBinding.ensureInitialized();<br>    <span class="hljs-keyword">await</span> Firebase.initializeApp();<br><br>    FlutterError.onError =<br>       FirebaseCrashlytics.instance.recordFlutterFatalError;<br><br>    runApp(MyApp());<br>  &#125;, (error, stack) =&gt;<br>    FirebaseCrashlytics.instance.recordError(error, stack, fatal: <span class="hljs-keyword">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>如需查看有关如何处理其他类型错误的示例，请参阅<a href="https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=flutter&authuser=0">自定义崩溃报告</a>。</p><h2 id="第-3-步：强制造成一次测试崩溃以完成设置"><a href="#第-3-步：强制造成一次测试崩溃以完成设置" class="headerlink" title="第 3 步：强制造成一次测试崩溃以完成设置"></a><strong>第 3 步</strong>：强制造成一次测试崩溃以完成设置</h2><p>如需完成 Crashlytics 设置并在 Firebase 控制台的 Crashlytics 信息中心内查看初始数据，您需要强制抛出一个测试异常。</p><ol><li><p>向您的应用添加可用于强制抛出测试异常的代码。</p><p>如果您添加了一个对顶级 <code>Zone</code> 调用 <code>FirebaseCrashlytics.instance.recordError(error, stack, fatal: true)</code> 的错误处理程序，可以使用以下代码向应用添加一个按下即会抛出测试异常的按钮：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">TextButton(<br>    onPressed: () =&gt; <span class="hljs-keyword">throw</span> Exception(),<br>    child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;Throw Test Exception&quot;</span>),<br>),<br></code></pre></td></tr></table></figure></li><li><p>构建并运行您的应用。</p></li><li><p>强制抛出测试异常，以便发送您的应用的第一个报告：</p><ol><li>在测试设备或模拟器上打开应用。</li><li>在您的应用中，按下您使用上述代码添加的测试异常按钮。</li></ol></li><li><p>前往 Firebase 控制台的 <a href="https://console.firebase.google.com/project/_/crashlytics?authuser=0">Crashlytics 信息中心</a>，查看您的测试崩溃报告。</p><p>如果您已刷新控制台，但在五分钟后仍未看到测试崩溃报告，请<a href="https://firebase.google.com/docs/crashlytics/test-implementation?authuser=0#enable-debug-logging">启用调试日志记录</a>，查看您的应用是否正在发送崩溃报告。</p></li></ol><p>大功告成！Crashlytics 现在会监控您的应用是否发生崩溃，以及 Android 中的非严重错误和 ANR。您可以访问 <a href="https://console.firebase.google.com/project/_/crashlytics?authuser=0">Crashlytics 信息中心</a>，查看和调查所有报告和统计信息。</p><h2 id="实际体验问题"><a href="#实际体验问题" class="headerlink" title="实际体验问题"></a>实际体验问题</h2><ul><li>公司wifi网络情况下，上报接口异常</li><li>蜂窝网络情况下，启动时候上报正常，使用期间上报接口异常</li><li>蜂窝网络情况下，手机蓝灯app开代理，启动时候上报正常，使用期间上报接口正常</li></ul><blockquote><p><a href="https://firebaselogging-pa.googleapis.com/v1/firelog/legacy/batchlog">https://firebaselogging-pa.googleapis.com/v1/firelog/legacy/batchlog</a><br>Status Code: 200</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
